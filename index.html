<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Make more time">
<meta property="og:type" content="website">
<meta property="og:title" content="易天行">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="易天行">
<meta property="og:description" content="Make more time">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="易天行">
<meta name="twitter:description" content="Make more time">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>易天行</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">易天行</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">积累点滴，汇聚江河</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/2019-05-29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/2019-05-29/" itemprop="url">linux日常命令记录2(一直更新)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T00:00:00+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>linux命令繁杂，确必不可少，这里用来总结日常用的命令记录，随时更新…</p>
</blockquote>
<h3 id="free-看内存"><a href="#free-看内存" class="headerlink" title="free 看内存"></a>free 看内存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -s 3 # 持续刷新，每3s</span><br><span class="line">free -m 以M展示</span><br><span class="line">free -g 以G展示</span><br><span class="line">free -h 更友好的展示，自动选择单位</span><br></pre></td></tr></table></figure>
<p><img src="evernotecid://851D1360-9E5F-4949-9CED-AC96DA44F46E/appyinxiangcom/2703947/ENResource/p1967" alt="0a725b553b252959a8cb9d6d2cb3ba4c.png"></p>
<ul>
<li>total 本机的物理内存+swap</li>
<li>used 已使用的内存和swap</li>
<li>free 尚未分配的内存和swap</li>
<li>shared 被共享的内存的大小，一般可以忽略</li>
<li>buff/cache buffer 和 cache 使用的物理内存大小。</li>
<li>available 列显示还可以被应用程序使用的物理内存大小。</li>
</ul>
<p>公式：</p>
<ul>
<li><code>available = free + buffer/cache</code></li>
<li><code>total = used + avaliable</code> </li>
</ul>
<blockquote>
<p>free available : 在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？<br>free 是真正尚未被使用的物理内存数量。available 是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，<code>available = free + buffer + cache</code>。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。</p>
</blockquote>
<h5 id="另一种显示："><a href="#另一种显示：" class="headerlink" title="另一种显示："></a>另一种显示：</h5><p><img src="evernotecid://851D1360-9E5F-4949-9CED-AC96DA44F46E/appyinxiangcom/2703947/ENResource/p1968" alt="23bec7597f02a9a6e74d6ca833d4a733.png"></p>
<ul>
<li>total 物理内总量</li>
<li>used 所有已使用的内存，包括实际使用的+bufers + cached</li>
<li>free 未被分配的内存</li>
<li>shared 共享内存，一般不会用到</li>
<li>buffers 系统分配但未被使用的buffers数量</li>
<li>cached 系统分配但未被使用的cache数量</li>
<li>第二行 buffers/cache<ul>
<li>used2 实际使用的buffers 与cache总量，也是实际使用的内存总量</li>
<li>free2 未被使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。</li>
</ul>
</li>
</ul>
<p>故：<br>total1 = used1 + free1<br>total1 = used2 + free2<br>used1 = buffers1 + cached1 + used2<br>free2 = free1 + buffers1 + cached1</p>
<blockquote>
<p>那么为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ </p>
</blockquote>
<p>这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。当你知道了这些故事之后，输出中列的名称可能已经不再重要了。</p>
<h3 id="ss-网络监控"><a href="#ss-网络监控" class="headerlink" title="ss 网络监控"></a>ss 网络监控</h3><p>ss命令用于显示socket状态，建议使用ss命令替代netstat部分命令,例如netsat -ant/lnt等.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time netstat -lnp | wc -l</span><br><span class="line">time ss -lnp | wc -l</span><br></pre></td></tr></table></figure>
<p><code>ss -tlnp | grep 3100</code></p>
<ul>
<li>-n 地址使用数字展示（端口默认展示为别名）</li>
<li>-p 展示端口所在的进程信息</li>
<li>-l 展示listening的端口</li>
<li>-t TCP</li>
<li>-u UDP</li>
</ul>
<p>或者</p>
<p><code>ss -tlnp sport = :3100</code><br>sport = :3100<br>用于过滤</p>
<h3 id="vmstat-机器综合监测mem-cpu-io"><a href="#vmstat-机器综合监测mem-cpu-io" class="headerlink" title="vmstat 机器综合监测mem,cpu,io"></a>vmstat 机器综合监测mem,cpu,io</h3><p><code>vmstat 1 1000</code> 每秒刷新一次，1000次</p>
<p>字段含义说明：</p>
<ul>
<li>Procs（进程）<ul>
<li>r 等待执行的任务数。展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈。</li>
<li>B 等待IO的进程数量</li>
</ul>
</li>
<li>Memory(内存)<ul>
<li>swpd 正在使用虚拟的内存大小，单位k</li>
<li>free 空闲内存大小</li>
<li>buff 已用的buff大小，对块设备的读写进行缓冲</li>
<li>cache 已用的cache大小，文件系统的cache</li>
<li>inact 非活跃内存大小，即被标明可回收的内存，区别于free和active</li>
<li>active 活跃的内存大小</li>
</ul>
</li>
<li>Swap<ul>
<li>si 每秒从交换区写入内存的大小（单位：kb/s）（注意是写入）</li>
<li>so 每秒从内存写到交换区的大小</li>
</ul>
</li>
<li>IO<ul>
<li>bi 每秒读取的块数（读磁盘）（<strong>注意是读！就是读！</strong>）。现在的Linux版本块的大小为1024bytes。</li>
<li>bo 每秒写入的块数（写磁盘）</li>
</ul>
</li>
<li>system<ul>
<li>in 每秒中断数，包括时钟中断,这两个值越大，会看到由内核消耗的cpu时间会越多</li>
<li>cs 每秒上下文切换数</li>
</ul>
</li>
<li>CPU（以百分比表示）<ul>
<li>Us 用户进程执行消耗cpu时间(user time)。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了</li>
<li>Sy 系统进程消耗cpu时间(system time)。sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。</li>
<li>Id 空闲时间(包括IO等待时间)</li>
<li>wa 等待IO时间。Wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>关于bi,bo,wa:</strong> vmstat下表io下面的bi表示读取和bo表示写入，单位是block（硬盘读写的最小单位是扇区，一个扇区是512 bytes。一次硬盘读写的数据量不会超过512 bytes，这一次读写的数据量就称为1个block。在大文件的读写操作中，基本可以按乘512来根据block计算出读写的实际数据量，误差很小。）cpu下面的wa，这个wa就是wait的缩写，代表的意思是CPU在等待硬盘读写操作的时间，用百分比表示。wait越大则机器io性能就越差。</p>
</blockquote>
<h3 id="iostat-磁盘性能"><a href="#iostat-磁盘性能" class="headerlink" title="iostat 磁盘性能"></a>iostat 磁盘性能</h3><p><code>iostat 1 10</code> 每1s刷新一次，刷新十次</p>
<h3 id="ps-进程统计"><a href="#ps-进程统计" class="headerlink" title="ps 进程统计"></a>ps 进程统计</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep nginx</span><br><span class="line">$ sudo lsof -nP -i:9300 <span class="comment"># 端口 -&gt; 进程</span></span><br><span class="line">$ sudo netstat -tlnp | grep port <span class="comment"># 端口 -&gt; 进程</span></span><br><span class="line">$ sudo lsof -p 12764 | grep TCP <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line">$ sudo netstat -tlnp | grep pid <span class="comment"># 进程 -&gt; 端口</span></span><br></pre></td></tr></table></figure>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>查看进程正在打开文件、网络、socket的状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx  <span class="comment">#进程名 -&gt; pid</span></span><br><span class="line">sudo lsof -i :9300 <span class="comment"># 端口号 -&gt; 进程</span></span><br><span class="line">sudo lsof -i @140.143.60.140  <span class="comment"># ip地址 -&gt; 进程</span></span><br><span class="line">lsof -p 12764 | grep TCP <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line">或者</span><br><span class="line">lsof -i | grep 12764 <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line">lsof -p 12764 <span class="comment"># 进程 -&gt; 打开资源状态，包括文件、网络、socket等</span></span><br><span class="line"></span><br><span class="line">-n no host names</span><br><span class="line">-P no port names</span><br><span class="line">-i  select by IPv[46] address: [46][proto][@host|addr][:svc_list|port_list]</span><br><span class="line">-p exclude(^)|select PIDs</span><br></pre></td></tr></table></figure>
<p>mac:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -i :20002</span><br><span class="line">sudo lsof -p 1234 -P # -P显示端口号</span><br></pre></td></tr></table></figure>
<h3 id="netstat-网络"><a href="#netstat-网络" class="headerlink" title="netstat 网络"></a>netstat 网络</h3><p>查看当前的网络连接状态，主要用来查看本机和外部的的网络连接，包括端口，连接情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -anp <span class="comment"># 所有端口</span></span><br><span class="line">netstat -tlnp <span class="comment"># 所有listening的tcp端口</span></span><br><span class="line"></span><br><span class="line">netstat -tlnp | grep tcp | grep port <span class="comment"># 端口 -&gt; 进程</span></span><br><span class="line">netstat -tlnp | grep pid <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line"></span><br><span class="line">$ netstat -at <span class="comment"># 所有 tcp</span></span><br><span class="line">$ netstat -au <span class="comment"># 所有 udp </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -p （root）Show the PID and name of the program to which each socket belongs</span></span><br><span class="line"><span class="comment"># -n 不显示主机\端口\用户名,加速输出</span></span><br><span class="line"><span class="comment"># -t 显示tcp连接</span></span><br><span class="line"><span class="comment"># -u 显示udp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -a Show both listening and non-listening (for TCP this means established  connections)  sockets</span></span><br><span class="line"><span class="comment"># -l Show only listening sockets.  (These are omitted by default.)</span></span><br></pre></td></tr></table></figure>
<h3 id="top-实时监控os"><a href="#top-实时监控os" class="headerlink" title="top 实时监控os"></a>top 实时监控os</h3><p>命令参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -p 11232 # 仅展示某个进程</span><br><span class="line">top -H -p pid # 显示某个进程所有活跃的线程消耗情况。</span><br><span class="line">top -c  # 展示进程详细信息</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<ul>
<li>-p 监控特定的PID</li>
<li>-c 命令行列显示程序名以及参数</li>
<li>-H 设置为线程模式</li>
</ul>
<p>快捷键总结：</p>
<ul>
<li>V 大写V，以进程树的形式展示命令行列</li>
<li>c 命令行列显示程序名以及参数</li>
<li>E 更改总体内存展示单位</li>
<li>e 更改每个进程内存展示的单位</li>
<li>1 展示每个单核的负荷</li>
<li>P 大写P 按cpu排序</li>
<li>M 大写M 按内存排序</li>
<li>t 可以更动态的展示cpu</li>
<li>m 更动态的展示内存</li>
<li>f 更改展示字段</li>
<li>s 改变更新周期</li>
<li>%cpu可能会超过100%,因为是多核心负荷的累加。如果是12核机器，最多可达1200%！。使用<code>cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</code>查看核心数</li>
</ul>
<p>实用的内部命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下：</span><br><span class="line">s – 改变画面更新频率</span><br><span class="line">l – 关闭或开启第一部分第一行 top 信息的表示</span><br><span class="line">t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示</span><br><span class="line">m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示</span><br><span class="line">N – 以 PID 的大小的顺序排列表示进程列表</span><br><span class="line">P – 以 CPU 占用率大小的顺序排列进程列表</span><br><span class="line">M – 以内存占用率大小的顺序排列进程列表</span><br><span class="line">h – 显示帮助</span><br><span class="line">n – 设置在进程列表所显示进程的数量</span><br><span class="line">q – 退出 top</span><br><span class="line">s – 改变画面更新周期</span><br></pre></td></tr></table></figure>
<p>字段含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序号 列名 含义</span><br><span class="line">a PID 进程id</span><br><span class="line">b PPID 父进程id</span><br><span class="line">c RUSER Real user name</span><br><span class="line">d UID 进程所有者的用户id</span><br><span class="line">e USER 进程所有者的用户名</span><br><span class="line">f GROUP 进程所有者的组名</span><br><span class="line">g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?</span><br><span class="line">h PR 优先级</span><br><span class="line">i NI nice值。负值表示高优先级，正值表示低优先级</span><br><span class="line">j P 最后使用的CPU，仅在多CPU环境下有意义</span><br><span class="line">k %CPU 上次更新到现在的CPU时间占用百分比</span><br><span class="line">l TIME 进程使用的CPU时间总计，单位秒</span><br><span class="line">m TIME+ 进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">n %MEM 进程使用的物理内存百分比</span><br><span class="line">o VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">p SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。</span><br><span class="line">q RES 驻留内存大小。驻留内存是任务使用的非交换物理内存大小，RES=CODE+DATA</span><br><span class="line">r CODE 可执行代码占用的物理内存大小，单位kb</span><br><span class="line">s DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</span><br><span class="line">t SHR 共享内存大小，单位kb</span><br><span class="line">u nFLT 页面错误次数</span><br><span class="line">v nDRT 最后一次写入到现在，被修改过的页面数。</span><br><span class="line">w S 进程状态（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</span><br><span class="line">x COMMAND 命令名/命令行</span><br><span class="line">y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名</span><br><span class="line">z Flags 任务标志，参考 sched.h</span><br><span class="line"></span><br><span class="line">默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。</span><br><span class="line"></span><br><span class="line">通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。</span><br><span class="line">按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。</span><br><span class="line">按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。</span><br></pre></td></tr></table></figure>
<h3 id="ip-查看ip地址"><a href="#ip-查看ip地址" class="headerlink" title="ip 查看ip地址"></a>ip 查看ip地址</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip addr  <span class="comment"># 网络状态</span></span><br><span class="line">ifconfig <span class="comment"># 网络状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 外网地址</span></span><br><span class="line">$ curl ifconfig.me</span><br><span class="line">$ curl icanhazip.com</span><br><span class="line">$ curl ident.me</span><br></pre></td></tr></table></figure>
<h2 id="ls-展示文件创建时间"><a href="#ls-展示文件创建时间" class="headerlink" title="ls 展示文件创建时间"></a>ls 展示文件创建时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac:</span><br><span class="line">ls -lT</span><br><span class="line">-T 参数展示详细时间</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">ls --full-time</span><br><span class="line">ls -la --time-style=full-iso</span><br><span class="line">--full-time</span><br><span class="line">--time-style=full-iso</span><br></pre></td></tr></table></figure>
<h2 id="ps进程启动时间"><a href="#ps进程启动时间" class="headerlink" title="ps进程启动时间"></a>ps进程启动时间</h2><p>ps -ef、ps aux命令可以展示进程的大概信息，启动时间展示不完整，如果想得知进程的详细启动时间，怎么办呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux:</span><br><span class="line">$ ps -eo pid,lstart,cmd</span><br><span class="line"></span><br><span class="line">outPut:</span><br><span class="line">PID                  STARTED CMD</span><br><span class="line">    1 Mon Jun 19 21:31:08 2017 /sbin/init</span><br><span class="line">    2 Mon Jun 19 21:31:08 2017 [kthreadd]</span><br><span class="line">    3 Mon Jun 19 21:31:08 2017 [ksoftirqd/0]</span><br></pre></td></tr></table></figure>
<h2 id="cpu系统信息查看proc"><a href="#cpu系统信息查看proc" class="headerlink" title="cpu系统信息查看proc"></a>cpu系统信息查看proc</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux内核信息</span></span><br><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br><span class="line"><span class="comment"># 查看linux发行版信息</span></span><br><span class="line">lsb_release -a</span><br><span class="line"><span class="comment"># cpu核心数</span></span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c </span><br><span class="line"><span class="comment"># 内存情况</span></span><br><span class="line">cat /proc/meminfo</span><br><span class="line">free</span><br><span class="line"><span class="comment"># 磁盘情况</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"></span><br><span class="line">Linux查看物理CPU个数、核数、逻辑CPU个数</span><br><span class="line"><span class="comment"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数</span></span><br><span class="line"><span class="comment"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span></span><br><span class="line"><span class="comment"># 查看物理CPU个数</span></span><br><span class="line">cat /proc/cpuinfo| grep <span class="string">"physical id"</span>| sort| uniq| wc -l</span><br><span class="line"><span class="comment"># 查看每个物理CPU中core的个数(即核数)</span></span><br><span class="line">cat /proc/cpuinfo| grep <span class="string">"cpu cores"</span>| uniq</span><br><span class="line"><span class="comment"># 查看逻辑CPU的个数</span></span><br><span class="line">cat /proc/cpuinfo| grep <span class="string">"processor"</span>| wc -l</span><br><span class="line"><span class="comment"># 查看CPU信息（型号）</span></span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure>
<h3 id="pidstat-展示进程资源占用统计"><a href="#pidstat-展示进程资源占用统计" class="headerlink" title="pidstat 展示进程资源占用统计"></a>pidstat 展示进程资源占用统计</h3><p>使用示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidstat [ 选项 ] [ &lt;时间间隔&gt; ] [ &lt;次数&gt; ]</span><br><span class="line"></span><br><span class="line"># pid4989的cpu详细详细，每个1s打印一次，打印8次</span><br><span class="line">pidstat -u -p 4989 1 8</span><br><span class="line"># 内存</span><br><span class="line">pidstat -r -p 4989 1 8</span><br><span class="line"># 磁盘</span><br><span class="line">pidstat -d -p 4989 1 8</span><br><span class="line"># 展示三者</span><br><span class="line">pidstat -urd -p 4989 1 8</span><br><span class="line"># -h 在一行展示所有信息</span><br><span class="line">pidstat -urdh -p 4989 1 8</span><br><span class="line"># 更多</span><br><span class="line">man pidstat</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-u：默认的参数，显示各个进程的cpu使用统计</span><br><span class="line">-r：显示各个进程的内存使用统计</span><br><span class="line">-d：显示各个进程的IO使用情况</span><br><span class="line">-p：指定进程号</span><br><span class="line">-w：显示每个进程的上下文切换情况</span><br><span class="line">-t：显示选择任务的线程的统计信息外的额外信息</span><br><span class="line">-T &#123; TASK | CHILD | ALL &#125;</span><br><span class="line">这个选项指定了pidstat监控的。TASK表示报告独立的task，CHILD关键字表示报告进程下所有线程统计信息。ALL表示报告独立的task和task下面的所有线程。</span><br><span class="line">注意：task和子线程的全局的统计信息和pidstat选项无关。这些统计信息不会对应到当前的统计间隔，这些统计信息只有在子线程kill或者完成的时候才会被收集。</span><br><span class="line">-V：版本号</span><br><span class="line">-h：在一行上显示了所有活动，这样其他程序可以容易解析。</span><br><span class="line">-I：在SMP环境，表示任务的CPU使用率/内核数量</span><br><span class="line">-l：显示命令名和所有参数</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/2019-04-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/2019-04-20/" itemprop="url">node进程监控PM2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:00:00+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>pm2是什么？它是一个node的进程管理和监控工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>
</blockquote>
<p><a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="callcheat"><a href="#callcheat" class="headerlink" title="callcheat"></a>callcheat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Fork mode</span><br><span class="line">pm2 start app.js --name my-api # Name process</span><br><span class="line"></span><br><span class="line"># Cluster mode</span><br><span class="line">pm2 start app.js -i 0        # Will start maximum processes with LB depending on available CPUs</span><br><span class="line">pm2 start app.js -i max      # Same as above, but deprecated.</span><br><span class="line">pm2 scale app +3             # Scales `app` up by 3 workers</span><br><span class="line">pm2 scale app 2              # Scales `app` up or down to 2 workers total</span><br><span class="line"></span><br><span class="line"># Listing</span><br><span class="line"></span><br><span class="line">pm2 list               # Display all processes status</span><br><span class="line">pm2 jlist              # Print process list in raw JSON</span><br><span class="line">pm2 prettylist         # Print process list in beautified JSON</span><br><span class="line"></span><br><span class="line">pm2 describe 0         # Display all informations about a specific process</span><br><span class="line"></span><br><span class="line">pm2 monit              # Monitor all processes</span><br><span class="line"></span><br><span class="line"># Logs</span><br><span class="line"></span><br><span class="line">pm2 logs [--raw]       # Display all processes logs in streaming</span><br><span class="line">pm2 flush              # Empty all log files</span><br><span class="line">pm2 reloadLogs         # Reload all logs</span><br><span class="line"></span><br><span class="line"># Actions</span><br><span class="line"></span><br><span class="line">pm2 stop all           # Stop all processes</span><br><span class="line">pm2 restart all        # Restart all processes</span><br><span class="line"></span><br><span class="line">pm2 reload all         # Will 0s downtime reload (for NETWORKED apps)</span><br><span class="line"></span><br><span class="line">pm2 stop 0             # Stop specific process id</span><br><span class="line">pm2 restart 0          # Restart specific process id</span><br><span class="line"></span><br><span class="line">pm2 delete 0           # Will remove process from pm2 list</span><br><span class="line">pm2 delete all         # Will remove all processes from pm2 list</span><br><span class="line"></span><br><span class="line"># Misc</span><br><span class="line"></span><br><span class="line">pm2 reset &lt;process&gt;    # Reset meta data (restarted time...)</span><br><span class="line">pm2 updatePM2          # Update in memory pm2</span><br><span class="line">pm2 ping               # Ensure pm2 daemon has been launched</span><br><span class="line">pm2 sendSignal SIGUSR2 my-app # Send system signal to script</span><br><span class="line">pm2 start app.js --no-daemon</span><br><span class="line">pm2 start app.js --no-vizion</span><br><span class="line">pm2 start app.js --no-autorestart</span><br></pre></td></tr></table></figure>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><a href="http://pm2.keymetrics.io/docs/usage/log-management/#reloading-all-logs" target="_blank" rel="noopener">日志官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Display option for pm2 logs command</span><br><span class="line">pm2 logs -h</span><br><span class="line"></span><br><span class="line"># Display all apps logs</span><br><span class="line">pm2 logs</span><br><span class="line"></span><br><span class="line"># Display only logs about process containing &quot;api&quot; in their name</span><br><span class="line">pm2 logs /api/</span><br><span class="line"></span><br><span class="line"># It&apos;s a regex so you can filter with the normal syntax to filter with OR condition</span><br><span class="line">pm2 logs /server_[12]/</span><br><span class="line"></span><br><span class="line"># Display only api app logs</span><br><span class="line">pm2 logs api</span><br><span class="line"></span><br><span class="line"># Display X lines of api log file</span><br><span class="line">pm2 logs big-api --lines 1000</span><br></pre></td></tr></table></figure>
<h3 id="cluster模块"><a href="#cluster模块" class="headerlink" title="cluster模块"></a>cluster模块</h3><blockquote>
<p>node.js试运行在v8引擎上的，以单线程的方式运行，在多核心处理器的系统中并不能发挥其最大性能。可以使用cluster模块，下面<br>是一个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);  </span><br><span class="line"><span class="keyword">var</span> http    = <span class="built_in">require</span>(<span class="string">'http'</span>);  </span><br><span class="line"><span class="keyword">var</span> os      = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numCPUs = os.cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;  </span><br><span class="line">  <span class="comment">// Master:</span></span><br><span class="line">  <span class="comment">// Let's fork as many workers as you have CPU cores</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; ++i) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Worker:</span></span><br><span class="line">  <span class="comment">// Let's spawn a HTTP server</span></span><br><span class="line">  <span class="comment">// (Workers can share any TCP connection.</span></span><br><span class="line">  <span class="comment">//  In this case its a HTTP server)</span></span><br><span class="line"></span><br><span class="line">  http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">"hello world"</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pm2替代cluster模块"><a href="#pm2替代cluster模块" class="headerlink" title="pm2替代cluster模块"></a>pm2替代cluster模块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 原始代码</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer(function(req, res) &#123;  </span><br><span class="line">  res.writeHead(200);</span><br><span class="line">  res.end(&quot;hello world&quot;);</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure>
<p>执行<code>pm2 start app.js -i 4</code>,<code>-i &lt;number of workers&gt;</code>参数用来告诉PM2以cluster_mode的形式运行你的app（对应的叫fork_mode），后面的数字表示要启动的工作线程的数量。如果给定的数字为0，PM2则会根据你CPU核心的数量来生成对应的工作线程。</p>
<p>优点：</p>
<ul>
<li>不论什么情况下，你的应用将一直运行,如果任意一个工作线程挂了，PM2会立即重启一个。</li>
<li>实时扩展集群，如果你需要增加工作线程的数量，可以通过<code>pm2 scale &lt;app name&gt; &lt;n&gt;</code>来对集群进行扩展。参数<n>指定工作线程的数量，被用来增加或减少集群数。你也可以通过<code>pm2 scale app +3</code>的方式来指定要增加多少工作线程。</n></li>
<li>生产环境零停机更新。PM2的<code>reload &lt;app name&gt;</code>功能将依次重启所有的工作线程。每一个线程会等待在新的线程创建之后才会被终止掉。</li>
<li><code>使用gracefulReload功能可以达到相同的目的</code>，不同的是它不会立即终止工作线程，而是通过IPC发送一个shutdown信号来关闭所有当前的连接并处理一些自定义的任务，然后再优雅地退出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.on(&apos;message&apos;, function(msg) &#123;  </span><br><span class="line">  if (msg === &apos;shutdown&apos;) &#123;</span><br><span class="line">    close_all_connections();</span><br><span class="line">    delete_cache();</span><br><span class="line">    server.close();</span><br><span class="line">    process.exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="PM2使用"><a href="#PM2使用" class="headerlink" title="PM2使用"></a>PM2使用</h2><ul>
<li>安装 <code>npm install -g pm2</code></li>
<li>更多命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ npm install -g pm2</span><br><span class="line"><span class="comment"># 启动 --name tank是给这个进程取个名字</span></span><br><span class="line">$ pm2 start index.js --name tankName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用命令</span></span><br><span class="line"><span class="variable">$pm2</span> stop  &lt;app_name|id|all&gt;  停止</span><br><span class="line"></span><br><span class="line"><span class="variable">$pm2</span> delete &lt;app_name|id|all&gt; 删除</span><br><span class="line"></span><br><span class="line"><span class="variable">$pm2</span> restart &lt;app_name|id|all&gt; 重启</span><br><span class="line"></span><br><span class="line"><span class="variable">$pm2</span> reload &lt;app_name|id|all&gt; 重载</span><br></pre></td></tr></table></figure>
<p>跟多命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pm2 start app.js -i 4 #后台运行pm2，启动4个app.js </span><br><span class="line">                                # 也可以把&apos;max&apos; 参数传递给 start</span><br><span class="line">                                # 正确的进程数目依赖于Cpu的核心数目</span><br><span class="line">$ pm2 start app.js --name my-api # 命名进程</span><br><span class="line">$ pm2 list               # 显示所有进程状态</span><br><span class="line">$ pm2 monit              # 监视所有进程</span><br><span class="line">$ pm2 logs               #  显示所有进程日志</span><br><span class="line">$ pm2 stop all           # 停止所有进程</span><br><span class="line">$ pm2 restart all        # 重启所有进程</span><br><span class="line">$ pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">$ pm2 stop 0             # 停止指定的进程</span><br><span class="line">$ pm2 restart 0          # 重启指定的进程</span><br><span class="line">$ pm2 startup            # 产生 init 脚本 保持进程活着</span><br><span class="line">$ pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">$ pm2 delete 0           # 杀死指定的进程</span><br><span class="line">$ pm2 delete all         # 杀死全部进程</span><br><span class="line"></span><br><span class="line">运行进程的不同方式：</span><br><span class="line">$ pm2 start app.js -i max  # 根据有效CPU数目启动最大进程数目</span><br><span class="line">$ pm2 start app.js -i 3      # 启动3个进程</span><br><span class="line">$ pm2 start app.js -x        #用fork模式启动 app.js 而不是使用 cluster</span><br><span class="line">$ pm2 start app.js -x -- -a 23   # 用fork模式启动 app.js 并且传递参数 (-a 23)</span><br><span class="line">$ pm2 start app.js --name serverone  # 启动一个进程并把它命名为 serverone</span><br><span class="line">$ pm2 stop serverone       # 停止 serverone 进程</span><br><span class="line">$ pm2 start app.json        # 启动进程, 在 app.json里设置选项</span><br><span class="line">$ pm2 start app.js -i max -- -a 23                   #在--之后给 app.js 传递参数</span><br><span class="line">$ pm2 start app.js -i max -e err.log -o out.log  # 启动 并 生成一个配置文件</span><br><span class="line">你也可以执行用其他语言编写的app  ( fork 模式):</span><br><span class="line">$ pm2 start my-bash-script.sh    -x --interpreter bash</span><br><span class="line">$ pm2 start my-python-script.py -x --interpreter python</span><br><span class="line"></span><br><span class="line">0秒停机重载:</span><br><span class="line">这项功能允许你重新载入代码而不用失去请求连接。</span><br><span class="line">注意：</span><br><span class="line">仅能用于web应用</span><br><span class="line">运行于Node 0.11.x版本</span><br><span class="line">运行于 cluster 模式（默认模式）</span><br><span class="line">$ pm2 reload all</span><br><span class="line"></span><br><span class="line">CoffeeScript:</span><br><span class="line">$ pm2 start my_app.coffee  #这就是全部</span><br><span class="line"></span><br><span class="line">PM2准备好为产品级服务了吗？</span><br><span class="line">只需在你的服务器上测试</span><br><span class="line">$ git clone https://github.com/Unitech/pm2.git</span><br><span class="line">$ cd pm2</span><br><span class="line">$ npm install  # 或者 npm install --dev ，如果devDependencies 没有安装</span><br><span class="line">$ npm test</span><br></pre></td></tr></table></figure>
<p>错误日志位置：</p>
<p>error log path  /root/.pm2/pids/anaweb-13.pid </p>
<p>错误日志，出现启动 error找她就没错</p>
<p>out log path    /root/.pm2/logs/anaweb-out-13.log </p>
<p>参考1: <a href="https://cnodejs.org/topic/5021c2cff767cc9a51e684e3" target="_blank" rel="noopener">https://cnodejs.org/topic/5021c2cff767cc9a51e684e3</a><br>参考2: <a href="http://tcrct.iteye.com/blog/2043644" target="_blank" rel="noopener">http://tcrct.iteye.com/blog/2043644</a><br>forever github: <a href="https://github.com/foreverjs/forever" target="_blank" rel="noopener">https://github.com/foreverjs/forever</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/2019-04-20-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/2019-04-20-2/" itemprop="url">linux日常命令记录(一直更新)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-20T00:00:00+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>linux命令繁杂，确必不可少，这里用来总结日常用的命令记录，随时更新…</p>
</blockquote>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep nginx</span><br><span class="line">$ sudo lsof -nP -i:9300 <span class="comment"># 端口 -&gt; 进程</span></span><br><span class="line">$ sudo netstat -tlnp | grep port <span class="comment"># 端口 -&gt; 进程</span></span><br><span class="line">$ sudo lsof -p 12764 | grep TCP <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line">$ sudo netstat -tlnp | grep pid <span class="comment"># 进程 -&gt; 端口</span></span><br></pre></td></tr></table></figure>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>查看进程正在打开文件、网络、socket的状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx  <span class="comment">#进程名 -&gt; pid</span></span><br><span class="line">sudo lsof -i :9300 <span class="comment"># 端口号 -&gt; 进程</span></span><br><span class="line">sudo lsof -i @140.143.60.140  <span class="comment"># ip地址 -&gt; 进程</span></span><br><span class="line">lsof -p 12764 | grep TCP <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line">或者</span><br><span class="line">lsof -i | grep 12764 <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line">lsof -p 12764 <span class="comment"># 进程 -&gt; 打开资源状态，包括文件、网络、socket等</span></span><br><span class="line"></span><br><span class="line">-n no host names</span><br><span class="line">-P no port names</span><br><span class="line">-i  select by IPv[46] address: [46][proto][@host|addr][:svc_list|port_list]</span><br><span class="line">-p exclude(^)|select PIDs</span><br></pre></td></tr></table></figure>
<p>mac:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -i :20002</span><br><span class="line">sudo lsof -p 1234 -P # -P显示端口号</span><br></pre></td></tr></table></figure>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看当前的网络连接状态，主要用来查看本机和外部的的网络连接，包括端口，连接情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -anp <span class="comment"># 所有端口</span></span><br><span class="line">netstat -tlnp <span class="comment"># 所有listening的tcp端口</span></span><br><span class="line"></span><br><span class="line">netstat -tlnp | grep tcp | grep port <span class="comment"># 端口 -&gt; 进程</span></span><br><span class="line">netstat -tlnp | grep pid <span class="comment"># 进程 -&gt; 端口</span></span><br><span class="line"></span><br><span class="line">$ netstat -at <span class="comment"># 所有 tcp</span></span><br><span class="line">$ netstat -au <span class="comment"># 所有 udp </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -p （root）Show the PID and name of the program to which each socket belongs</span></span><br><span class="line"><span class="comment"># -n 不显示主机\端口\用户名,加速输出</span></span><br><span class="line"><span class="comment"># -t 显示tcp连接</span></span><br><span class="line"><span class="comment"># -u 显示udp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -a Show both listening and non-listening (for TCP this means established  connections)  sockets</span></span><br><span class="line"><span class="comment"># -l Show only listening sockets.  (These are omitted by default.)</span></span><br></pre></td></tr></table></figure>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看当前的系统进程状态，实时刷新</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>查看内存占用情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">free -m <span class="comment"># 以M为单位查看</span></span><br></pre></td></tr></table></figure>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip addr <span class="comment"># 网络状态</span></span><br><span class="line">ifconfig <span class="comment"># 网络状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 外网地址</span></span><br><span class="line">$ curl ifconfig.me</span><br><span class="line">$ curl icanhazip.com</span><br><span class="line">$ curl ident.me</span><br></pre></td></tr></table></figure>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac:</span><br><span class="line">ls -lT</span><br><span class="line">-T 参数展示详细时间</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">ls --full-time</span><br><span class="line">ls -la --time-style=full-iso</span><br><span class="line">--full-time</span><br><span class="line">--time-style=full-iso</span><br></pre></td></tr></table></figure>
<h3 id="ps进程启动时间"><a href="#ps进程启动时间" class="headerlink" title="ps进程启动时间"></a>ps进程启动时间</h3><p>ps -ef、ps aux命令可以展示进程的大概信息，启动时间展示不完整，如果想得知进程的详细启动时间，怎么办呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux:</span><br><span class="line">$ ps -eo pid,lstart,cmd</span><br><span class="line"></span><br><span class="line">outPut:</span><br><span class="line">PID                  STARTED CMD</span><br><span class="line">    1 Mon Jun 19 21:31:08 2017 /sbin/init</span><br><span class="line">    2 Mon Jun 19 21:31:08 2017 [kthreadd]</span><br><span class="line">    3 Mon Jun 19 21:31:08 2017 [ksoftirqd/0]</span><br></pre></td></tr></table></figure>
<ul>
<li>系统</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux内核信息</span></span><br><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看linux发行版信息</span></span><br><span class="line">lsb_release -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># cpu核心数</span></span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c </span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存情况</span></span><br><span class="line">cat /proc/meminfo</span><br><span class="line">free</span><br><span class="line"></span><br><span class="line"><span class="comment"># 磁盘情况</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机名</span></span><br><span class="line">hostname</span><br></pre></td></tr></table></figure>
<h3 id="pidstat-展示进程资源占用信息"><a href="#pidstat-展示进程资源占用信息" class="headerlink" title="pidstat 展示进程资源占用信息"></a>pidstat 展示进程资源占用信息</h3><p>使用示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidstat [ 选项 ] [ &lt;时间间隔&gt; ] [ &lt;次数&gt; ]</span><br><span class="line"></span><br><span class="line"># pid4989的cpu详细详细，每个1s打印一次，打印8次</span><br><span class="line">pidstat -u -p 4989 1 8</span><br><span class="line"># 内存</span><br><span class="line">pidstat -r -p 4989 1 8</span><br><span class="line"># 磁盘</span><br><span class="line">pidstat -d -p 4989 1 8</span><br><span class="line"># 展示三者</span><br><span class="line">pidstat -urd -p 4989 1 8</span><br><span class="line"># -h 在一行展示所有信息</span><br><span class="line">pidstat -urdh -p 4989 1 8</span><br><span class="line"># 更多</span><br><span class="line">man pidstat</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-u：默认的参数，显示各个进程的cpu使用统计</span><br><span class="line">-r：显示各个进程的内存使用统计</span><br><span class="line">-d：显示各个进程的IO使用情况</span><br><span class="line">-p：指定进程号</span><br><span class="line">-w：显示每个进程的上下文切换情况</span><br><span class="line">-t：显示选择任务的线程的统计信息外的额外信息</span><br><span class="line">-T &#123; TASK | CHILD | ALL &#125;</span><br><span class="line">这个选项指定了pidstat监控的。TASK表示报告独立的task，CHILD关键字表示报告进程下所有线程统计信息。ALL表示报告独立的task和task下面的所有线程。</span><br><span class="line">注意：task和子线程的全局的统计信息和pidstat选项无关。这些统计信息不会对应到当前的统计间隔，这些统计信息只有在子线程kill或者完成的时候才会被收集。</span><br><span class="line">-V：版本号</span><br><span class="line">-h：在一行上显示了所有活动，这样其他程序可以容易解析。</span><br><span class="line">-I：在SMP环境，表示任务的CPU使用率/内核数量</span><br><span class="line">-l：显示命令名和所有参数</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/2019-04-20-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/2019-04-20-1/" itemprop="url">git实用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T00:00:00+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="git小记"><a href="#git小记" class="headerlink" title="git小记"></a>git小记</h2><ul>
<li><a href="https://githowto.com/aliases" target="_blank" rel="noopener">https://githowto.com/aliases</a></li>
<li><code>git rebase -i HEAD~4</code>用来合并最近4次的提交</li>
<li><code>git log origin/master</code>查看的是本地版本库的origin/master分支，如果要看远程，需要先<code>git fetch</code>从远程取下来再<code>git ls orign/master</code></li>
<li><code>工作区</code> <code>暂存区</code> <code>本地版本库</code> <code>远程版本库</code></li>
<li><code>git rebase branchname</code>是变基合并，它不会产生新的merge记录，会把之前的提交记录依次放在本分支；</li>
<li>尽量不要在master分支<code>git rebase branch</code>操作</li>
<li><code>git commit --amend</code>用于修改上一次commit信息</li>
<li><code>git reflog</code>用于查看git操作日志，可以方便的用<code>git reset --hard hashid</code>回滚，或<code>git reset --hard HEAD^</code>到上一个版本</li>
<li><code>git push origin dev:dev</code>是推送分支到远程的命令；dev和dev存在追踪关系时，<code>git push origin dev</code>；当前分支且存在追踪关系，<code>git push origin</code>；只有一个远程分支，且当前分支存在远程追踪关系<code>git push</code></li>
<li><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>同push,<code>git pull</code> <code>git pull origin shaoc</code> 都是简写</li>
<li><code>git merge --no-ff shaoc</code>不使用fast-forward,肯定会生成一个合并历史，方便查看历史。<code>git merge</code>如果不存在冲突的时候，默认会使用fast-forward就不会生成新的commit</li>
<li><code>git pull --rebase</code>,fetch后，合并时使用rebase方式,等于<code>git fetch + git merge</code>;<code>git pull</code> = <code>git fetch + git rebase</code> </li>
<li><code>git stash</code>功能是把所有没有提交的修改暂存到stash里面。可用<code>git stash pop</code>恢复,<code>git stash drop</code>用于删除。</li>
<li><code>stash save message</code>推荐使用，等价于<code>stash push -m &quot;message&quot;</code>;如果要暂存部分，<code>stash push log/file -m &quot;sth&quot;</code></li>
<li><code>git checkout -b b1 origin/master</code>表示从<code>origin/master</code>创建并切换分支b1</li>
</ul>
<p>场景1：多人开发当前dev分支，拉取代码可以使用<code>git pull --rebase</code>，避免生成多余记录；但是如果冲突太多，一个个合并就太麻烦了，需要使用<code>git pull</code></p>
<p>场景2：分支feature正在开发，最好及时拉取master的最新代码合并，可以使用<code>git merge --no-ff origin/master</code>,强制记一条记录；如果冲突不多，使用<code>git rebase origin/master</code>，把master的提交记录都平移过来</p>
<p>场景3：分支阶段开发完成，需要合会主分支，请使用<code>git merge --no-ff branch</code>,这样不管有没有冲突都会记录一条commit信息；如果预计没有冲突，且想把分支的提交记录平移过来，而不是只记录一条提交日志，请使用<code>git rebase branch</code>,不推荐这样，是因为会导致主分支的commit历史记录收到影响。</p>
<blockquote>
<p><code>合并是很常见的操作，那么到底什么时间改用什么命令呢</code>？两者的使用需要，具体看冲突commit次数的多少，是否想要平移commit记录，是否需要记录一次merge历史，根据需求自行选择；</p>
</blockquote>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ul>
<li><code>git stash</code> 暂存</li>
<li><code>git stash save &#39;shaoc&#39;</code>推荐加一个message，等价于<code>git stash push -m &quot;message&quot;</code></li>
<li><code>stash list</code> 查看</li>
<li><code>stash drop [name]</code>,默认移除最近一个</li>
<li><code>stash clear</code>, 清空stash list</li>
<li><code>stash show [name]</code>,查看某个stash</li>
<li><code>stash pop</code></li>
<li><code>stash apply</code></li>
</ul>
<p>默认情况下，git stash会缓存下列文件：</p>
<ul>
<li>添加到暂存区的修改（staged changes）</li>
<li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但不会缓存以下文件：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>git stash命令提供了参数用于缓存上面两种类型的文件。使用<br><code>-u</code>或者<code>--include-untracked</code>可以<code>stash untracked</code>文件。使用-a或者–all命令可以stash当前目录下的所有修改。</p>
<h2 id="git-stash-push-和-git-stash-save"><a href="#git-stash-push-和-git-stash-save" class="headerlink" title="git stash push 和 git stash save"></a>git stash push 和 git stash save</h2><blockquote>
<p>git stash push 目前不被推荐使用了，推荐使用save</p>
</blockquote>
<p>功能相同点:</p>
<ul>
<li>用于本地存储修改，并加一个message说明，<code>git stash</code> <code>git stash save</code> <code>git stash push</code>这个三个命令是等价的</li>
</ul>
<p>不同：</p>
<ul>
<li>语法不同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这两者是等价的</span><br><span class="line">git stash save &quot;mytemp&quot;</span><br><span class="line">git stash push -m &quot;mytemp&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>push</code>和单独暂存某个文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 只暂存subDir.txt一个文件</span><br><span class="line">git stash push subDir/subDir.txt</span><br><span class="line">git stash save subDir/subDir.txt(不会生效)</span><br></pre></td></tr></table></figure>
<h2 id="git一些命令"><a href="#git一些命令" class="headerlink" title="git一些命令"></a>git一些命令</h2><p>分支-&gt;主干</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master  //切换分支</span><br><span class="line">git pull (--rebase)  //拉取代码,根据需要选择rebase或merge的冲突处理</span><br><span class="line">git merge shaoc     //合并，用merge</span><br><span class="line">git rebase shaoc    //合并，用rebase</span><br><span class="line">git commit and push //提交</span><br></pre></td></tr></table></figure>
<p>主干合并到分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout b1</span><br><span class="line">$ git pull (--rebae) //更新到最新</span><br><span class="line">$ git merge (--no-ff) origin/master  // merge合并,--no-ff强制生成一个commit记录，不论是否有冲突</span><br><span class="line">$ git rebase origin/master // rebase合并，线性历史，但一个个处理冲突</span><br><span class="line">$ git rebase --continue</span><br><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure>
<p>删除操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d Chapater8 //删除本地分支</span><br><span class="line">git push origin --delete shaoc //删除远程分支1</span><br><span class="line">git branch -r -d origin/cat //删除远程分支2</span><br><span class="line">git rm --cached readme1.txt //删除readme1.txt的跟踪，并保留在本地。</span><br><span class="line">git rm --f readme1.txt  //删除readme1.txt的跟踪，并且删除本地文件。</span><br></pre></td></tr></table></figure>
<p>fork合并操作步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//fork 情况下合并到本地分支</span><br><span class="line">//此时origin，为你自己的地址</span><br><span class="line">git remote add upstream URL</span><br><span class="line">git fetch upstream 拉去原作者的仓库更新</span><br><span class="line">git checkout master 切换到自己的master</span><br><span class="line">git merge upstream/master</span><br><span class="line">git rebase upstream/master</span><br><span class="line">merge或者rebase到你的master</span><br></pre></td></tr></table></figure>
<p>git reflog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog //查看历史</span><br><span class="line">git reset --hard hashid //跳转到某个id</span><br><span class="line">git reset --hard HEAD^  //跳转到前一个</span><br><span class="line">git show HEAD@&#123;2&#125; //查看某个记录</span><br></pre></td></tr></table></figure>
<p>强制拉取到最新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//强制拉取到最新</span><br><span class="line">git fetch --all //拉取所有remote</span><br><span class="line">git git reset --hard origin/master // 移动到origin/master</span><br><span class="line">（参考）</span><br><span class="line">git fetch //查看</span><br><span class="line">git checkout . // 情况本地所有工作区</span><br><span class="line">git stash //收藏本地所有内容</span><br></pre></td></tr></table></figure>
<p>git stash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 收藏文件或修改</span><br><span class="line">git stash</span><br><span class="line">git stash save &apos;message&apos; //保存时打标记</span><br><span class="line">git stash list</span><br><span class="line">git stash show stash@&#123;0&#125;</span><br><span class="line">git stash pop|apply</span><br><span class="line">git stash pop stash@&#123;0&#125;  //应用任意暂存到当前</span><br><span class="line">git diff file   //查看文件修改</span><br><span class="line">git stash drop stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>
<p>git branch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin dev  //本地dev分支，push到远程dev分支，不存在则创建</span><br><span class="line">git push origin dev:dev2 // 本地devpush到远程dev2</span><br><span class="line">git checkout -b branch1 origin/branch1 //从远程分支创建本地新分支并检出</span><br><span class="line"></span><br><span class="line">git branch //列出本地分支</span><br><span class="line">git branch -r //查看远程分支</span><br><span class="line">git branch -a //所有分支：本地 and 远程</span><br><span class="line">git branch dev //创建本地dev分支</span><br><span class="line">git branch -d dev  //删除本地dev分支</span><br><span class="line">git branch -r -d origin/dev //删除远程分支</span><br><span class="line">git branch -vv //查看本地分支对应的远程分支</span><br><span class="line">git branch -m oname newname //分支重命名</span><br></pre></td></tr></table></figure>
<p>git checkout</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkout的作用</span><br><span class="line">// 操作文件</span><br><span class="line">git checkout filename //放弃单个文件修改</span><br><span class="line">git checkout . 放弃当前目录下的修改</span><br><span class="line">// 操作分支</span><br><span class="line">git checkout master 切换分支</span><br><span class="line">git checkout -b branch1 //分支存在则只切换分支；不存在创建并切换到branch1</span><br><span class="line"></span><br><span class="line">git log</span><br><span class="line">git log -p -2 //-p 选项展开显示每次提交的内容差异</span><br></pre></td></tr></table></figure>
<p>简单步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout .</span><br><span class="line">git pull</span><br><span class="line">git stash pop  </span><br><span class="line">-&gt;处理冲突</span><br><span class="line">npm run lint</span><br><span class="line">-&gt;处理规范</span><br><span class="line">npm run commit</span><br></pre></td></tr></table></figure>
<p>alias<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.ls &quot;log --color --graph --date=format:&apos;%Y-%m-%d %H:%M:%S&apos; --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line">git config --global alias.lss &quot;log --color --stat --graph --date=format:&apos;%Y-%m-%d %H:%M:%S&apos; --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line">--author=&apos;shaoc&apos;</span><br><span class="line">--no-merges</span><br><span class="line"></span><br><span class="line">used:</span><br><span class="line">git ls</span><br><span class="line">git ls origin/master</span><br><span class="line">git ls --no-merges origin/master</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/2019-04-20-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/2019-04-20-3/" itemprop="url">Jvm命令操作解释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T00:00:00+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>介绍了分析java进程或线程的步骤？jstack,jstat,jinfo等命令的用法</p>
</blockquote>
<h3 id="分析步骤命令"><a href="#分析步骤命令" class="headerlink" title="分析步骤命令"></a>分析步骤命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检测运行状态</span></span><br><span class="line">$ top free</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程信息</span></span><br><span class="line">$ ps -ef | grep cc-doc [pid]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程堆栈</span></span><br><span class="line">$ jstack [-l] [-F] pid &gt; 1.txt</span><br><span class="line">$ sz 1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出线程信息，找到占用cpu\时间高的线程tid</span></span><br><span class="line">$ ps -mp pid -o THREAD,tid,time </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用linux命令tid转为16进制</span></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">"%x"</span> tid</span><br><span class="line"><span class="comment"># ee2f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看线程的堆栈信息，-A30显示后30行</span></span><br><span class="line">$ jstack pid | grep ee2f -A30</span><br></pre></td></tr></table></figure>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>“jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程[1]虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jstat [option vmid] [interval[s|ms] [count]]]</span><br><span class="line">$ jstat -gcutil pid 250 20</span><br><span class="line">$ jstat -gc pid 250 20  //250ms间隔，刷新20次</span><br></pre></td></tr></table></figure>
<h3 id="jstack-堆栈跟踪工具"><a href="#jstack-堆栈跟踪工具" class="headerlink" title="jstack 堆栈跟踪工具"></a>jstack 堆栈跟踪工具</h3><p>“jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）”<br>“线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># jstack -l 3500 </span><br><span class="line"># jstack -lm 3500 &gt; a.txt</span><br></pre></td></tr></table></figure>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><code>“jinfo（Configuration Info for Java）</code>的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$jinfo -flags pid</span><br><span class="line">$jinfo pid</span><br></pre></td></tr></table></figure>
<h3 id="jmap-java内存映像工具"><a href="#jmap-java内存映像工具" class="headerlink" title="jmap java内存映像工具"></a>jmap java内存映像工具</h3><blockquote>
<p>“jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）<br>如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如在第2章中用过的-XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX:+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件”</p>
</blockquote>
<p>“jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jmap -dump:format=b,file=dump.bin 21561 # 导出虚拟机dump文件</span><br><span class="line">$ jmap -heap # 显示虚拟机堆信息</span><br><span class="line"></span><br><span class="line"># jmap -heap 21561</span><br><span class="line">输出：</span><br><span class="line">Attaching to process ID 21561, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.77-b03</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 1073741824 (1024.0MB)</span><br><span class="line">   NewSize                  = 89128960 (85.0MB)</span><br><span class="line">   MaxNewSize               = 357564416 (341.0MB)</span><br><span class="line">   OldSize                  = 179306496 (171.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 135790592 (129.5MB)</span><br><span class="line">   used     = 47917952 (45.6981201171875MB)</span><br><span class="line">   free     = 87872640 (83.8018798828125MB)</span><br><span class="line">   35.28812364261583% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 47710208 (45.5MB)</span><br><span class="line">   used     = 229376 (0.21875MB)</span><br><span class="line">   free     = 47480832 (45.28125MB)</span><br><span class="line">   0.4807692307692308% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 49283072 (47.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 49283072 (47.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 463470592 (442.0MB)</span><br><span class="line">   used     = 202372448 (192.99740600585938MB)</span><br><span class="line">   free     = 261098144 (249.00259399414062MB)</span><br><span class="line">   43.66457149453832% used</span><br><span class="line"></span><br><span class="line">22290 interned Strings occupying 2157896 bytes.</span><br></pre></td></tr></table></figure>
<h3 id="jhat-内存快照分析工具"><a href="#jhat-内存快照分析工具" class="headerlink" title="jhat 内存快照分析工具"></a>jhat 内存快照分析工具</h3><p>“JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照”<br>“一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器[1]上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，后文将会介绍到的VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer[2]等工具，都能实现比jhat更强大更专业的分析功能”</p>
<p><code>$ jhat dump.bin //一般用不到</code></p>
<h3 id="可视化监测工具-jconsole，jvisualvm"><a href="#可视化监测工具-jconsole，jvisualvm" class="headerlink" title="可视化监测工具 jconsole，jvisualvm"></a>可视化监测工具 jconsole，jvisualvm</h3><ul>
<li>“其中JConsole是在JDK 1.5时期就已经提供的虚拟机监控工具，而VisualVM在JDK 1.6 Update7中才首次发布，现在已经成为Sun（Oracle）主力推动的多合一故障处理工具[1]，并且已经从JDK中分离出来成为可以独立发展的开源项目。JConsole（Java Monitoring and Management Console）是一种基于JMX的可视化监视、管理工具。”</li>
</ul>
<p>启动命令，mac、windows可以在机器上直接启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jconsole</span><br><span class="line">$ jvisualvm</span><br></pre></td></tr></table></figure>
<ul>
<li>“VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具”, “VisualVM在JDK 1.6 update 7中才首次出现，但并不意味着它只能监控运行于JDK 1.6上的程序，它具备很强的向下兼容能力，甚至能向下兼容至近10年前发布的JDK 1.4.2平台[1]”</li>
</ul>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><ol>
<li>Java运行时内存分为5个部分：<ul>
<li>程序计数器（Program Counter Register） 当前线程所执行的字节码的行号指示器，是线程私有的</li>
<li>java虚拟机栈（VM stack） 描述的是java方法执行时的内存模型，每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等。每个方法调用直到执行完成，就对应着一个栈在虚拟机中从入栈到出栈的过程。经常有人把java内存分为栈内存和堆内存，栈就是现在讲的虚拟机栈，或者说是其中的局部变量表部分。线程私有的，生命周期与线程相同。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError,允许动态扩展但是内存不够时，会抛出OutOfMemoryError</li>
<li>本地方法栈（Native Method Stack） 与Vm stack相似，不过他用于为本地方法服务</li>
<li>java堆（Heap） 被所有线程共享的区域，启动JVM时初始化，所有对象实例以及数组都要在堆上分配。它是垃圾回收器管理的主要区域，也称为GC堆。可以分为新生代和老年代，再细致一点有Eden空间、From Survivor空间、To Survivor空间。堆内存不够时，会抛出OutOfMemory异常</li>
<li>方法区（Method Area） 各个线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池属于方法区的一部分。</li>
</ul>
</li>
</ol>
<blockquote>
<p>jvm内存区域详见： “深入理解Java虚拟机：JVM高级特性与最佳实践。” 第二章、2.2节、 Apple Books.</p>
</blockquote>
<ol>
<li>HotSpot虚拟机常见的垃圾收集器：</li>
</ol>
<ul>
<li>“Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。”“Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择”</li>
<li>“ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。”</li>
<li>“Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器”；“Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。；停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。”</li>
<li>“Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用”</li>
<li>“Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”</li>
<li>“CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。；从名字（包含”Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：初始标记（CMS initial mark）并发标记（CMS concurrent mark）重新标记（CMS remark）并发清除（CMS concurrent sweep）”</li>
<li><p>“G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点” ：</p>
<ul>
<li><p>“并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p>
</li>
<li><p>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p>
</li>
<li><p>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行[…]”</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>垃圾收集器详见： “深入理解Java虚拟机：JVM高级特性与最佳实践。” 第三章、3.5节、 Apple Books.</p>
</blockquote>
<ol>
<li><p>对象已死的判断：<br>引用计数法：无法解决循环引用的问题<br>可达性分析算法：判断从gcRoots是否可达（<code>Java、c#等主流商用语言都用这个算法</code>）<br>详见： “深入理解Java虚拟机：JVM高级特性与最佳实践。” 第三章、3.2节、</p>
</li>
<li><p>回收算法：<br>标记清除；复制；标记整理；分代收集算法<br>详见： “深入理解Java虚拟机：JVM高级特性与最佳实践。” 第三章、3.3节、</p>
</li>
<li><p>内存分配策略</p>
</li>
</ol>
<ul>
<li>对象优先在新生代的Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC；</li>
<li>大对象直接进入老年代；</li>
<li>长期存活的对象直接进入老年代；</li>
</ul>
<ol>
<li>Minor GC和Full GC有什么不一样吗？</li>
</ol>
<ul>
<li><p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
</li>
<li><p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。”</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/03/2018-12-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/2018-12-04/" itemprop="url">为什么要用redmine</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Redmine是个项目管理软件。如何降低沟通成本、如何规避开发风险、如何压缩项目人力？这些问题看似高屋建瓴，实际上都不是非高手不可触及的。</p>
</blockquote>
<p>假设有一个研发团队，L是老大，他负责接入需求并安排任务。</p>
<p>##一、分配任务<br>L理解某波需求后，会拉上相关人讨论，讲一下为什么做，做成什么样，怎么做。<br>会后，经常有不清楚的、不理解的、有矛盾的问题会问到L，L的时间就这么被碎片化的浪费掉了。<br>而且，那些讨论出来的实现思路、设计方法，以及之后琐碎问题及答案都没有被记录了下来，<br>日后需要回顾的时候，只能靠脑子回忆，或者找人帮你回忆了。<br>不管对于L来说，还是对组员们来说，需要一个地方记录下这些事，无论是当时还是半个月后，总会有用到的时候。<br>用Redmine的话<br><strong>L理解需求后，创建Task及其子Task，并指派给相应的人，在Task描述上写清楚任务内容。<br>相关人会收到任务通知，查看任务内容后，对不理解的、有疑问的地方进行回复询问，然后等待L回复解答。<br>无论时隔多久，大家都可以检索到什么时候做了什么事、遇到哪些问题、当初的设计思路是什么等内容。</strong></p>
<h2 id="二、任务跟踪"><a href="#二、任务跟踪" class="headerlink" title="二、任务跟踪"></a>二、任务跟踪</h2><p>L答应产品经理说xx时间点完成项目，所以他要清楚每个人是否能在这个点之前完成任务，而且要时不时的问一下每个人完成进度如何。<br>组员对于L来说往往是个黑盒，往往只有在任务完成或者要延期时，盒子才会被打开，才能知道，哦~完成了呀，或者，哦？为什么延期？<br>L无法做到及时的延期风险控制，真的非常不专业。<br>用Redmine的话<br><strong>组员每天下班前更新自己的任务进度，登记工时，并写上今天完成的内容。<br>L可以随时看到这些进度和任务内容，通过项目甘特图，就能及时发现风险并对其进行事先规避。
</strong> </p>
<h2 id="三、周报"><a href="#三、周报" class="headerlink" title="三、周报"></a>三、周报</h2><p>L需要每周对上汇报团队工作进度，所以他也要求组员们每周都要发周报给他。<br>可是组员们对写周报真的很反感，每次都要努力的回忆这周做了什么，还要计算好工时，不能让L觉得自己偷懒，必要的时候还要编一点。<br>用Redmine的话<br>因为每天的工作有TASK记录，并有工时记录，所以周报只需要点几下鼠标就能导出了，上边有本周详尽的工作内容以及消耗的工时。</p>
<h2 id="四、线上操作"><a href="#四、线上操作" class="headerlink" title="四、线上操作"></a>四、线上操作</h2><p>线上系统的升级、维护、事故处理等都需要严格的执行步骤，特别是与钱有关的关键服务，都要谨慎处理。<br>但是经常会有人马虎大意，不是忘记这个就是忘记那个，一不小心，公司就损失了xx万，执行人可能会被批斗一顿，L也会被要求加强流程管理。<br>领导说的轻松，一句我们要有流程呀，L就要好好想想了，怎么保证不出错呢？<br>用Redmine的话<br><strong>线上操作的执行人创建一个TASK，写清楚操作的目的，步骤，以及每一步的check方法。<br>写完后他需要找另外一个人进行review，检查步骤是否合理，是否有遗漏，有问题就回复抛出建议，没问题就回复review通过。<br>通过后执行人才可以执行，关键步骤最好也让审核人在旁边看着操作，完成后让审核人检查执行结果。<br>这样做到了至少双人的double check，而且线上操作的TASK记录了操作的整个过程，一旦出现问题，回顾以及追责都是非常方便的。</strong></p>
<h2 id="五、项目Wiki"><a href="#五、项目Wiki" class="headerlink" title="五、项目Wiki"></a>五、项目Wiki</h2><p>Word、PPT、PDF、邮件，写文档、发文档、更新文档，要不要这么麻烦！<br>我们需要一个集中的、有层次的、方便分享的文档管理工具，那就是Wiki。<br>Redmine的Wiki本身的优势并不大，但是一个明显的好处是它和项目、版本、甚至具体TASK结合在一起。<br>比如在某个Task中需要出一个小文档，那就可以写一个Wiki页面，并附在Task中，反过来依然可以。<br>就像自从超市有了灯泡卖，就不用非要去五金店买了，你要的，都在Redmine上了，而且都是彼此关联的。</p>
<h2 id="六、其他说明："><a href="#六、其他说明：" class="headerlink" title="六、其他说明："></a>六、其他说明：</h2><ol>
<li>能否让工具发挥它应有的作用，不是工具本身好不好，关键看使用者是否好好发挥它。<br>很多团队只是简单的用一下Redmine，Task更新不及时，Wiki组织不当，都反而会让Redmine成为一个累赘。<br>所以，重点是培养团队的习惯，而不只是学会用Redmine而已。</li>
<li>上述优势并不是Redmine的全部，还有很多值得发觉的亮点在，这些只是我亲身带一个团队使用它之后，给我们团队带来的好处。</li>
<li>像L这种项目管理的角色，能做的都做好，尽量减少组员不必要的沟通和打断，不能只做个需求传达者，<br>有些事先想好，然后告诉每个人他们要做的事即可，这样能大大提高团队整体的工作效率，尤其是对程序员这种需要静下心来不被打断的工种，一定要好好呵护。<br>当然，L还要尽量让组员了解大局，了解为什么，不能让他们认为自己只是个螺丝钉而已，要让他们成为操着整个航母心的螺丝钉</li>
</ol>
<p>&lt;完&gt;</p>
<blockquote>
<p><a href="https://www.cnblogs.com/zuohongming/p/4495164.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuohongming/p/4495164.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/27/2018-11-23-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/27/2018-11-23-1/" itemprop="url">数据结构中的几种树的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-27T00:00:00+08:00">
                2018-11-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见的树结构"><a href="#常见的树结构" class="headerlink" title="常见的树结构"></a>常见的树结构</h1><p>B-/+</p>
<p>平衡二叉树</p>
<p>红黑树</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/23/2018-11-23-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/23/2018-11-23-2/" itemprop="url">mongoDB索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-23T00:00:00+08:00">
                2018-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>mongo支持多种index类型，其最大的作用就是提高查询性能，可以避免对collection的逐文档扫描。index保存指定的或者多个field值，并且按照field值的顺序排序，索引条目的有序性使得“相等比较eq”、range查询等性能很高。<br>mongo内部的索引结构采用<strong>B-/+</strong>树来实现，单次对索引的查询最多访问h（层高）个节点，时间复杂度为O(logN)。</p>
</blockquote>
<h3 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建索引</span></span><br><span class="line">db.collec.createIndex(&#123;<span class="attr">age</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">unique</span>:<span class="literal">true</span>,<span class="attr">sparse</span>:<span class="literal">true</span>,<span class="attr">background</span>:<span class="literal">true</span>,<span class="attr">expireAfterSeconds</span>:<span class="number">10</span>,<span class="attr">name</span>:<span class="string">"index_name"</span>&#125;)</span><br><span class="line"></span><br><span class="line">db.collection.getIndexes()</span><br><span class="line">db.collection.dropIndex(<span class="string">"indexName"</span>)</span><br><span class="line">db.collection.dropIndexes() <span class="comment">//删除所有</span></span><br><span class="line">db.col.totalIndexSize()     <span class="comment">// 查看索引大小 (bytes)</span></span><br><span class="line">db.col.totalSize()          <span class="comment">//集合大小 (bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique sparse background expireAfterSeconds参数下面会有说明</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p>
</blockquote>
<ul>
<li>mongo提供两种建所以的方式<code>foreground</code>和<code>background</code>。foreground（默认）即前台操作，它会阻塞用户对数据的读写操作直到index构建完毕，即任何需要获取read、write操作都会阻塞；background即后台模式，不阻塞数据读写操作，独立的后台线程异步构建索引，此时仍然允许对数据的读写操作；其中background比foreground更加耗时。</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>下面我们要说的mongo最常用的几种索引类型,有<code>_id索引</code> <code>单字段索引</code> <code>组合索引</code> <code>复合索引</code> <code>地理空间索引</code> <code>文本索引</code> <code>哈希索引</code>等</p>
<ol>
<li><strong>_id索引</strong>：每个document都必须有_id字段，如果不指定，mongodb会默认生成；_id字段为内置的“唯一索引”，整个collection中不会存在_id值相同的document，这是mongodb的内部机制，开发者无法改变，也不需要开发者显式的为_id建立索引，当然也无法remove它。通过_id字段来查询document是性能极高的，所以如果尽可能的通过_id查询或者update数据。</li>
<li><strong>单字段索引</strong> 也叫普通索引，对单个字段建立的索引</li>
<li><strong>组合索引Compound</strong> 对多个field建立的索引。比如{user:1,age:-1}，索引条目按user正序排列，相同user索引条目再根据age值倒序排列。需要特别注意的是<code>索引的field顺序很重要!</code>。需要结合具体的查询和排序去分析，下面会提到建组合索引的注意事项</li>
<li><strong>复合键索引（Multikey）</strong> 对document中的数组字段创建索引，就是复合键索引</li>
<li><strong>地理空间索引（Geospatial）</strong> 为了支持高效的地址位置数据查询，mongodb提供了2种特殊的索引，2d索引（坐标平面）和2sphere索引（经纬球面）</li>
<li><strong>文本索引（Text）</strong> 支持对collection中的string内容进行搜索操作，即text search；mongodb内置支持几种语言的分词，不过这种文本搜索的能力与专业的搜索引擎相比，还相当简陋。不支持中文~</li>
<li><strong>哈希索引（Hash）</strong> 主要使用场景为“hash sharding”，即在“Sharding”架构模式中，对sharding key使用hash索引，以便数据的sharding和路由操作。hash索引只支持一个字段，它不能和其他字段组合，同时也不能是“unique”，使用<code>db.&lt;collection&gt;.createIndex({a : &quot;hashed&quot;})</code>来创建hash索引。</li>
</ol>
<h3 id="索引属性（property）"><a href="#索引属性（property）" class="headerlink" title="索引属性（property）"></a>索引属性（property）</h3><ol>
<li><p><strong>唯一索引（Unique）</strong>：即索引字段的值是唯一的，全局无重复；如果尝试存入重复的值（write），操作将会被拒绝。可以通过db.<collection>.createIndex({ “userid” : 1}, {unique : true})创建唯一索引。我们可以对一个组合索引使用unique属性，表示它们的组合值不能重复，默认情况下unique为false。如果插入的document不包含某个索引字段，那么此字段的值保存为null，mongodb也会用unique约束这样的文档，即不包含某个字段的文档只能保存一条。比如唯一索引{“x” : 1, “y” : 1}，只能插入一条{“x” : “content”}（等同于{“x” : “content”,”y” : null}）。对于hash索引而言，则不能使用unique属性。unique通常与sparse一起使用。</collection></p>
</li>
<li><p><strong>稀疏索引（Sparse）</strong> ：只有当document中包含索引字段时，才会为此文档建立索引，但是这些文档仍然能够保存成功·；因为mongodb的document结构是模式自由的，所以document中不包含某个Field也是“正常的”；稀疏索引将会忽略那些document中不包含索引字段的记录，因此稀疏索引并没有包含collection中的所有文档；非sparse索引，将会为那些缺失的字段存储为null，因此索引包含了全部文档。  我们可以将“Sparse”和“Unique”选项同时约束一个index，以避免包含重复值的document，同时还忽略那些不包含索引字段的document（不建立索引，但是文档仍然会被保存）。当sparse与unique同时约束索引时，比如createIndex({“score” : 1}, {sparse : true, unique: true})，如果文档中不包含score字段，那么文档都可以保存成功，但是不会对这些文档建立索引，但是对于包含了score字段的文档，那么score值则不能重复。</p>
</li>
<li><strong>TTL索引</strong> 对“date”、“timestamp”类型的字段建立TTL索引，并在索引选项中指定索引保存的时长，那么mongodb将会在一定时间之后自动移除那些“过期”的索引和documents。通过TTL索引，可以实现一个清洗数据的“定时任务”。TTL索引只能支持一个字段（同hash索引，不能对组合索引使用此特性），不能和其他字段组合，即一个索引中只能有一个字段；比如document中created字段类型为date，表示文档插入的时间，我们希望文档在3600秒后过期删除，那么可以通过db.<collection>.createIndex({ “created” : 1},{expireAfterSeconds : 3600})创建索引，其中“expireAfterSeconds”为TTL索引的必须选项。如果document中不包含索引字段，文档将不会过期。mongodb将会创建一个后台线程，读取index值并删除那些过期的document；在createIndex时，mongodb也会在构建索引的同时检测过期，删除那些过期的数据。TTL索引和众多的缓存服务一样，不能保证数据过期则立即被删除（对用户操作不可见），mongodb扫描数据（从头到尾）是有时间间隔的（60秒），因此过期数据的删除可能存在延迟问题。对于“replica Set”，这个后台线程只在primary上运行，primary上的删除操作同步给secondaries。mongodb的存储引擎的特性决定，这种大量的随机删除会导致严重的存储碎片，索引如果collection中存在TTL索引时，将会开启“usePowerOf2Sizes”选项而且不能修改，“usePowerOf2Sizes”可以降低存储碎片的可能。<code>collection.createIndex(new Document(&quot;created&quot;,1),new IndexOptions().expireAfter(15L,TimeUnit.MILLISECONDS));</code></collection></li>
</ol>
<h3 id="索引的基本策略"><a href="#索引的基本策略" class="headerlink" title="索引的基本策略"></a>索引的基本策略</h3><p>虽然索引可以提高query的查询效率，当然也会增加write时带来的开支，增加内存、磁盘的使用。建索引时要根据业务的<strong>查询和排序条件</strong>来合理选择。</p>
<blockquote>
<p>索引的选择性。是判定一个索引筛选数据的能力，越高效的索引其选择性越高，即可以排除掉更多的不匹配数据，更少的数据遍历。比如文档中有一个字段status，这个status有2个合法值“new”、“processed”，如果在status字段上建立索引，那么此索引的选择性就比较低，因为它只能筛选掉一半数据，这也意味着即使索引生效，也需要遍历整个collection中一半的数据才能得到最终结果，事实上对status建立索引是没有必要的。</p>
</blockquote>
<ul>
<li><strong>索引支持匹配最左前缀</strong>，比如索引{x: 1, y : 1}能支持 {x : 1} 和 {x : 1, y : 1}两个key的查询。</li>
<li><strong>尽量避免大量数据内存排序</strong> 设计索引时尽量能直接获取到排好序的结果，性能最好；如果不能，mongo可以将数据进行内存中的排序，在没有使用索引情况下排序操作所占用内存不得超过32M，否则将中断排序。</li>
<li><strong>多字段索引顺序很重要</strong> sort操作使用索引时必须要和index顺序一致，比如索引{a : 1, b : 1}，将不支持sort( { b : 1, a : 1})；且排序的方向必须和index声明的保持一致，比如上述索引支持{a : 1, b : 1} 和 { a : -1, b : -1}，但无法支持{a : 1, b : -1} 和 { a : -1, b : 1}。</li>
<li><p>查询和排序字段结合的分析</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 如果参与排序的字段（和顺序）和索引字段一样或者是索引的前缀字段，且查询条件中也包含索引的前缀字段，那么mongodb则可以使用索引进行排序，这是一种比较高效的做法。比如索引&#123; a : 1, b : 1, c : 1&#125;，如下查询均可以利用索引排序：</span><br><span class="line">db.data.find().sort( &#123; a: 1 &#125; )</span><br><span class="line">db.data.find().sort( &#123; a: -1 &#125; )</span><br><span class="line">db.data.find().sort( &#123; a: 1, b: 1 &#125; )</span><br><span class="line">db.data.find().sort( &#123; a: -1, b: -1 &#125; )</span><br><span class="line">db.data.find().sort( &#123; a: 1, b: 1, c: 1 &#125; )</span><br><span class="line">db.data.find( &#123; a: &#123; $gt: 4 &#125; &#125; ).sort( &#123; a: 1, b: 1 &#125; )</span><br><span class="line">    如果参与排序的字段不是索引的前缀字段，具体是否能够利用索引排序，就要求查询条件的字段需要为索引的最左前缀字段，同时查询条件的字段和sort字段的也应该构成组合索引的左前缀，比如索引 &#123; a : 1, b : 1, c: 1&#125;，那么此索引将支持如下几种排序方式：</span><br><span class="line">db.data.find( &#123; a: 5 &#125; ).sort( &#123; b: 1, c: 1 &#125; )</span><br><span class="line">db.data.find( &#123; b: 3, a: 4 &#125; ).sort( &#123; c: 1 &#125; )</span><br><span class="line">db.data.find( &#123; a: 5, b: &#123; $lt: 3&#125; &#125; ).sort( &#123; b: 1 &#125; )</span><br><span class="line">    如果查询字段和sort字段不能构成组合索引的左前缀，那么将不能高效的利用索引排序，或者有可能不会使用此索引，比如： </span><br><span class="line">db.data.find( &#123; a: &#123; $gt: 2 &#125; &#125; ).sort( &#123; c: 1 &#125; )</span><br><span class="line">db.data.find( &#123; c: 5 &#125; ).sort( &#123; c: 1 &#125; )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>1.索引覆盖查询<br>mongoDB可以做索引覆盖查询，这种查询不会访问指针指向的文档，而是直接用索引的数据返回结果。只有当要查询返回的字段，都在索引中的时候。</p>
<p>2.常见慢查询：<br>1).不等于和不包含查询一般不使用索引 $ne 或者$nin<br>2).通配符在前面的模糊查询， like ‘%xxx’<br>3).无索引的count 查询 和 排序（复合索引顺序不匹配）<br>4).多个范围查询（范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引）<br>5).skip跳过过多的行数<br>6).$where操作符</p>
<p>3.<strong>对现有的数据大表建立索引的时候，采用后台运行方式</strong></p>
<p><code>db.test.ensureIndex({&quot;username&quot;:1,&quot;age&quot;:-1},{&quot;background&quot;:true}) #默认情况下background是false。</code></p>
<h3 id="查询计划explain"><a href="#查询计划explain" class="headerlink" title="查询计划explain"></a>查询计划explain</h3><p><code>db.person.find( {age： 18} ).explain()</code>可以查看mongo的查询计划，包括索引的使用、文档扫描的多少、查询步骤等信息</p>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo-9552:PRIMARY&amp;gt; db.person.find(&#123;age: 18&#125;).explain()</span><br><span class="line">&#123;</span><br><span class="line">    &quot;queryPlanner&quot; : &#123;</span><br><span class="line">        &quot;plannerVersion&quot; : 1,</span><br><span class="line">        &quot;namespace&quot; : &quot;test.person&quot;,</span><br><span class="line">        &quot;indexFilterSet&quot; : false,</span><br><span class="line">        &quot;parsedQuery&quot; : &#123;</span><br><span class="line">            &quot;age&quot; : &#123;</span><br><span class="line">                &quot;$eq&quot; : 18</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;winningPlan&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">            &quot;inputStage&quot; : &#123;</span><br><span class="line">                &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">                &quot;keyPattern&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;indexName&quot; : &quot;age_1&quot;,</span><br><span class="line">                &quot;isMultiKey&quot; : false,</span><br><span class="line">                &quot;isUnique&quot; : false,</span><br><span class="line">                &quot;isSparse&quot; : false,</span><br><span class="line">                &quot;isPartial&quot; : false,</span><br><span class="line">                &quot;indexVersion&quot; : 1,</span><br><span class="line">                &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">                &quot;indexBounds&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : [</span><br><span class="line">                        &quot;[18.0, 18.0]&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;rejectedPlans&quot; : [ ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;serverInfo&quot; : &#123;</span><br><span class="line">        &quot;host&quot; : &quot;localhost&quot;,</span><br><span class="line">        &quot;port&quot; : 9552,</span><br><span class="line">        &quot;version&quot; : &quot;3.2.3&quot;,</span><br><span class="line">        &quot;gitVersion&quot; : &quot;b326ba837cf6f49d65c2f85e1b70f6f31ece7937&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stage常见类型"><a href="#stage常见类型" class="headerlink" title="stage常见类型"></a>stage常见类型</h4><p>如<code>explain.queryPlanner.winningPlan.stage</code>和<code>explain.queryPlanner.winningPlan.inputStage</code>等。<br>文档中仅有如下几类介绍</p>
<p><code>COLLSCAN</code> 全表扫描</p>
<p><code>IXSCAN</code> 索引扫描</p>
<p><code>FETCH</code> 根据索引去检索指定document</p>
<p><code>SHARD_MERGE</code> 将各个分片返回数据进行merge</p>
<p>但是根据源码中的信息，个人还总结了文档中没有的如下几类(常用如下，由于是通过源码查找，可能有所遗漏)</p>
<p><code>SORT</code> 表明在内存中进行了排序（与老版本的scanAndOrder:true一致）</p>
<p><code>LIMIT</code> 使用limit限制返回数</p>
<p><code>SKIP</code> 使用skip进行跳过</p>
<p><code>IDHACK</code> 针对_id进行查询</p>
<p><code>SHARDING_FILTER</code> 通过mongos对分片数据进行查询</p>
<p><code>COUNT</code> 利用db.coll.explain().count()之类进行count运算</p>
<p><code>COUNTSCAN</code> count不使用用Index进行count时的stage返回</p>
<p><code>COUNT_SCAN</code> count使用了Index进行count时的stage返回</p>
<p><code>SUBPLA</code> 未使用到索引的$or查询的stage返回</p>
<p><code>TEXT</code> 使用全文索引进行查询时候的stage返回</p>
<p> &lt;完&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/2018-11-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/2018-11-19/" itemprop="url">并发策略 cas算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T00:00:00+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发策略-CAS算法"><a href="#并发策略-CAS算法" class="headerlink" title="并发策略-CAS算法"></a>并发策略-CAS算法</h2><p>　　对于并发控制而言，我们平时用的<strong>锁（synchronized，Lock）</strong>是一种悲观的策略。它总是假设每一次临界区操作会产生冲突，因此，必须对每次操作都小心翼翼。如果多个线程同时访问临界区资源，就宁可牺牲性能让线程进行等待，所以锁会阻塞线程执行。</p>
<p>　　与之相对的有一种乐观的策略，它会假设对资源的访问是没有冲突的。既然没有冲突也就无需等待了，所有的线程都在不停顿的状态下持续执行。那如果遇到问题了无锁的策略使用一种叫做比较<strong>交换（CAS Compare And Swap）来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突。CAS算法是非阻塞的，它对死锁问题天生免疫，而且它比基于锁的方式拥有更优越的性能</strong>。</p>
<p>　　<strong>CAS算法的过程是这样：它包含三个参数 CAS（V,E,N）。V表示要更新的变量，E表示预期的值，N表示新值。仅当V值等于E值时，才会将V的值设置成N，否则什么都不做。最后CAS返回当前V的值</strong>。CAS算法需要你额外给出一个期望值，也就是你认为现在变量应该是什么样子，如果变量不是你想象的那样，那说明已经被别人修改过。你就重新读取，再次尝试修改即可。</p>
<p>　　JDK并发包有一个atomic包，里面实现了一些直接使用CAS操作的线程安全的类型。其中最常用的一个类应该就是AtomicInteger。我们以此为例来研究一下没有锁的情况下如何做到线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">//这是AtomicInteger类的核心字段，代表当前实际取值，借助volatile保证线程间数据的可见性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取内部数据的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们关注一下incrementAndGet()的内部实现　　</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">3</span>             <span class="keyword">int</span> current = get();</span><br><span class="line"><span class="number">4</span>             <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line"><span class="number">5</span>             <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line"><span class="number">6</span>                 <span class="keyword">return</span> next;</span><br><span class="line"><span class="number">7</span>         &#125;</span><br><span class="line"><span class="number">8</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>　　代码第二行使用了一个死循环，原因是：CAS的操作未必都是成功的，因此对于不成功的情况，我们就需要进行不断的尝试。第三行取得当前值，接着+1得到新值next。这里我们使用CAS必需的两个参数：期望值以及新值。使用compareAndSet()将新值next写入。成功的条件是在写入的时刻，当前的值应该要等于刚刚取到的current。如果不是这样则说明AtomicInteger的值在第3行到第5行之间被其他线程修改过了。当前看到的状态是一个过期的状态，因此返回失败，需要进行下一次重试，知道成功为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。大概的逻辑应该是这样：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == expect) &#123;</span><br><span class="line">    <span class="keyword">this</span> = update</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　CAS虽然能高效的解决原子问题，但是CAS也会带来1个经典问题即<strong>ABA问题</strong>：</p>
<p>　　因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>　　ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>
<p>　　从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类在内部不仅维护了对象值，还维护了一个时间戳（可以是任意的一个整数来表示状态值）。当设置对象值时，对象值和状态值都必须满足期望值才会写入成功。因此即使对象被反复读写，写会原值，只要状态值发生变化，就能防止不恰当的写入。　　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedReference 期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newReference 写入新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedStamp 期望状态值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newStamp 新状态值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">Pair&lt;V&gt; current = pair;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">  expectedReference == current.reference &amp;&amp;</span><br><span class="line">  expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">  ((newReference == current.reference &amp;&amp;</span><br><span class="line">    newStamp == current.stamp) ||</span><br><span class="line">   casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>— 不管多忙，每天给自己预留至少半小时的学习时间，拒绝做代码垃圾的搬运工！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/09/2018-10-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/2018-10-10/" itemprop="url">使用forever/pm2让node.js持久运行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-09T00:00:00+08:00">
                2018-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里我们讨论几种使node应用在后台运行的几种方式，简单的是<code>linux后台执行</code>，另外两种是使用进程管理工具<code>forever</code> <code>pm2</code>。</p>
<h2 id="linux-nohup-amp-命令"><a href="#linux-nohup-amp-命令" class="headerlink" title="linux nohup &amp; 命令"></a>linux nohup &amp; 命令</h2><p>使用<code>&amp;</code>符号后台执行，并利用<code>nohup</code>命令实现进程禁止挂起</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nohup node app.js &amp;</span><br></pre></td></tr></table></figure>
<h2 id="forever工具"><a href="#forever工具" class="headerlink" title="forever工具"></a>forever工具</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install forever -g   <span class="comment">#安装</span></span><br><span class="line">forever start app.js     <span class="comment">#启动应用</span></span><br><span class="line">forever stop app.js      <span class="comment">#关闭应用</span></span><br><span class="line">forever restartall       <span class="comment">#重启所有应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出日志和错误</span></span><br><span class="line">forever start -l forever.log -o out.log -e err.log app.js   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定forever信息输出文件，当然，默认它会放到~/.forever/forever.log</span></span><br><span class="line">forever start -l forever.log app.js  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定app.js中的日志信息和错误日志输出文件，  </span></span><br><span class="line"><span class="comment"># -o 就是console.log输出的信息，-e 就是console.error输出的信息</span></span><br><span class="line">forever start -o out.log -e err.log app.js </span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加日志，forever默认是不能覆盖上次的启动日志，  </span></span><br><span class="line"><span class="comment"># 所以如果第二次启动不加-a，则会不让运行  </span></span><br><span class="line">forever start -l forever.log -a app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听当前文件夹下的所有文件改动（不太建议这样）  </span></span><br><span class="line">forever start -w app.js  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有运行的服务 </span></span><br><span class="line">forever list  </span><br><span class="line"></span><br><span class="line"><span class="comment">######停止操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止所有运行的node App  </span></span><br><span class="line">forever stopall  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止其中一个node App  </span></span><br><span class="line">forever stop app.js  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然还可以这样  </span></span><br><span class="line"><span class="comment"># forever list 找到对应的id，然后：  </span></span><br><span class="line">forever stop [id]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发环境下  </span></span><br><span class="line">NODE_ENV=development forever start -l forever.log -e err.log -a app.js  </span><br><span class="line"><span class="comment"># 线上环境下  </span></span><br><span class="line">NODE_ENV=production forever start -l ~/.forever/forever.log -e ~/.forever/err.log -w -a app.js</span><br><span class="line"><span class="comment">#上面加上NODE_ENV为了让app.js辨认当前是什么环境用的</span></span><br><span class="line">The End</span><br></pre></td></tr></table></figure>
<h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>PM2是一个内置的负载平衡器Node.js应用生产过程管理。它允许您永久地保存应用程序，并在不停机的情况下重新加载它们</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ npm install -g pm2</span><br><span class="line"><span class="comment"># 启动 --name tank是给这个进程取个名字</span></span><br><span class="line">$ pm2 start index.js --name tankName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用命令</span></span><br><span class="line"><span class="variable">$pm2</span> stop  &lt;app_name|id|all&gt;  停止</span><br><span class="line"></span><br><span class="line"><span class="variable">$pm2</span> delete &lt;app_name|id|all&gt; 删除</span><br><span class="line"></span><br><span class="line"><span class="variable">$pm2</span> restart &lt;app_name|id|all&gt; 重启</span><br><span class="line"></span><br><span class="line"><span class="variable">$pm2</span> reload &lt;app_name|id|all&gt; 重载</span><br></pre></td></tr></table></figure>
<p>跟多命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pm2 start app.js -i 4 #后台运行pm2，启动4个app.js </span><br><span class="line">                                # 也可以把&apos;max&apos; 参数传递给 start</span><br><span class="line">                                # 正确的进程数目依赖于Cpu的核心数目</span><br><span class="line">$ pm2 start app.js --name my-api # 命名进程</span><br><span class="line">$ pm2 list               # 显示所有进程状态</span><br><span class="line">$ pm2 monit              # 监视所有进程</span><br><span class="line">$ pm2 logs               #  显示所有进程日志</span><br><span class="line">$ pm2 stop all           # 停止所有进程</span><br><span class="line">$ pm2 restart all        # 重启所有进程</span><br><span class="line">$ pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">$ pm2 stop 0             # 停止指定的进程</span><br><span class="line">$ pm2 restart 0          # 重启指定的进程</span><br><span class="line">$ pm2 startup            # 产生 init 脚本 保持进程活着</span><br><span class="line">$ pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">$ pm2 delete 0           # 杀死指定的进程</span><br><span class="line">$ pm2 delete all         # 杀死全部进程</span><br><span class="line"></span><br><span class="line">运行进程的不同方式：</span><br><span class="line">$ pm2 start app.js -i max  # 根据有效CPU数目启动最大进程数目</span><br><span class="line">$ pm2 start app.js -i 3      # 启动3个进程</span><br><span class="line">$ pm2 start app.js -x        #用fork模式启动 app.js 而不是使用 cluster</span><br><span class="line">$ pm2 start app.js -x -- -a 23   # 用fork模式启动 app.js 并且传递参数 (-a 23)</span><br><span class="line">$ pm2 start app.js --name serverone  # 启动一个进程并把它命名为 serverone</span><br><span class="line">$ pm2 stop serverone       # 停止 serverone 进程</span><br><span class="line">$ pm2 start app.json        # 启动进程, 在 app.json里设置选项</span><br><span class="line">$ pm2 start app.js -i max -- -a 23                   #在--之后给 app.js 传递参数</span><br><span class="line">$ pm2 start app.js -i max -e err.log -o out.log  # 启动 并 生成一个配置文件</span><br><span class="line">你也可以执行用其他语言编写的app  ( fork 模式):</span><br><span class="line">$ pm2 start my-bash-script.sh    -x --interpreter bash</span><br><span class="line">$ pm2 start my-python-script.py -x --interpreter python</span><br><span class="line"></span><br><span class="line">0秒停机重载:</span><br><span class="line">这项功能允许你重新载入代码而不用失去请求连接。</span><br><span class="line">注意：</span><br><span class="line">仅能用于web应用</span><br><span class="line">运行于Node 0.11.x版本</span><br><span class="line">运行于 cluster 模式（默认模式）</span><br><span class="line">$ pm2 reload all</span><br><span class="line"></span><br><span class="line">CoffeeScript:</span><br><span class="line">$ pm2 start my_app.coffee  #这就是全部</span><br><span class="line"></span><br><span class="line">PM2准备好为产品级服务了吗？</span><br><span class="line">只需在你的服务器上测试</span><br><span class="line">$ git clone https://github.com/Unitech/pm2.git</span><br><span class="line">$ cd pm2</span><br><span class="line">$ npm install  # 或者 npm install --dev ，如果devDependencies 没有安装</span><br><span class="line">$ npm test</span><br></pre></td></tr></table></figure>
<p>错误日志位置：</p>
<p>error log path  /root/.pm2/pids/anaweb-13.pid </p>
<p>错误日志，出现启动 error找她就没错</p>
<p>out log path    /root/.pm2/logs/anaweb-out-13.log </p>
<p>参考1: <a href="https://cnodejs.org/topic/5021c2cff767cc9a51e684e3" target="_blank" rel="noopener">https://cnodejs.org/topic/5021c2cff767cc9a51e684e3</a><br>参考2: <a href="http://tcrct.iteye.com/blog/2043644" target="_blank" rel="noopener">http://tcrct.iteye.com/blog/2043644</a><br>forever github: <a href="https://github.com/foreverjs/forever" target="_blank" rel="noopener">https://github.com/foreverjs/forever</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/09/2018-10-09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/2018-10-09/" itemprop="url">mongo中使用$type查询字段的BSON类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-09T00:00:00+08:00">
                2018-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><code>$type</code>操作符用来查询某个字段是否是的指定<code>BSON</code>类型。当文档的数据类型是高度的非结构化时，这非常的有用<br><code>{ field: { $type: &lt;BSON type&gt; } }</code>，你可以通过数组或别名来指定BSON的type<br><code>{ field: { $type: [ &lt;BSON type1&gt; , &lt;BSON type2&gt;, ... ] } }</code>，这将匹配数组中BSON类型的任意一个</p>
</blockquote>
<h2 id="BSON-type总结（version-3-2）"><a href="#BSON-type总结（version-3-2）" class="headerlink" title="BSON type总结（version 3.2）"></a>BSON type总结（version 3.2）</h2><p>3.2版本可以使用别名或数字来指定<code>BSON</code>类型，在3.2之前的版本只能使用数字来匹配。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Number</th>
<th>Alias</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>1</td>
<td>“double”</td>
<td></td>
</tr>
<tr>
<td>String</td>
<td>2</td>
<td>“string”</td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td>3</td>
<td>“object”</td>
<td></td>
</tr>
<tr>
<td>Array</td>
<td>4</td>
<td>“array”</td>
<td></td>
</tr>
<tr>
<td>Binary data</td>
<td>5</td>
<td>“binData”</td>
<td></td>
</tr>
<tr>
<td>Undefined</td>
<td>6</td>
<td>“undefined”</td>
<td>废弃</td>
</tr>
<tr>
<td>ObjectId</td>
<td>7</td>
<td>“objectId”</td>
<td></td>
</tr>
<tr>
<td>Boolean</td>
<td>8</td>
<td>“bool”</td>
<td></td>
</tr>
<tr>
<td>Date</td>
<td>9</td>
<td>“date”</td>
<td></td>
</tr>
<tr>
<td>Null</td>
<td>10</td>
<td>“null”</td>
<td></td>
</tr>
<tr>
<td>RegularExpression</td>
<td>11</td>
<td>“regex”</td>
<td></td>
</tr>
<tr>
<td>DBPointer</td>
<td>12</td>
<td>“dbPointer”</td>
<td></td>
</tr>
<tr>
<td>JavaScript</td>
<td>13</td>
<td>“javascript”</td>
<td></td>
</tr>
<tr>
<td>Sysmbol</td>
<td>14</td>
<td>“symbol”</td>
<td>废弃</td>
</tr>
<tr>
<td>JavaScript(with scope)</td>
<td>15</td>
<td>“javascriptWithScope”</td>
<td></td>
</tr>
<tr>
<td>32-bit integer</td>
<td>16</td>
<td>“int”</td>
<td></td>
</tr>
<tr>
<td>Timestamp</td>
<td>17</td>
<td>“timestamp”</td>
<td></td>
</tr>
<tr>
<td>64-bit integer</td>
<td>18</td>
<td>“long”</td>
<td></td>
</tr>
<tr>
<td>Decimal128</td>
<td>19</td>
<td>“decimal”</td>
<td>3.4版本新增</td>
</tr>
<tr>
<td>Min key</td>
<td>-1</td>
<td>“minKey”</td>
<td></td>
</tr>
<tr>
<td>Max Key</td>
<td>127</td>
<td>“maxKey”</td>
</tr>
</tbody>
</table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>源数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">      &#123; &quot;_id&quot; : 1, address : &quot;2030 Martian Way&quot;, zipCode : &quot;90698345&quot; &#125;,</span><br><span class="line">      &#123; &quot;_id&quot; : 2, address: &quot;156 Lunar Place&quot;, zipCode : 43339374 &#125;,</span><br><span class="line">      &#123; &quot;_id&quot; : 3, address : &quot;2324 Pluto Place&quot;, zipCode: NumberLong(3921412) &#125;,</span><br><span class="line">      &#123; &quot;_id&quot; : 4, address : &quot;55 Saturn Ring&quot; , zipCode : NumberInt(88602117) &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>查询zipCode字段是string的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.addressBook.find( &#123; &quot;zipCode&quot; : &#123; $type : 2 &#125; &#125; );</span><br><span class="line">//等价于</span><br><span class="line">db.addressBook.find( &#123; &quot;zipCode&quot; : &#123; $type : &quot;string&quot; &#125; &#125; );</span><br><span class="line"></span><br><span class="line">//返回结果</span><br><span class="line">&#123; &quot;_id&quot; : 1, &quot;address&quot; : &quot;2030 Martian Way&quot;, &quot;zipCode&quot; : &quot;90698345&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>zipCode的BSON类型是double的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.addressBook.find( &#123; &quot;zipCode&quot; : &#123; $type : 1 &#125; &#125; )</span><br><span class="line">//等价于</span><br><span class="line">db.addressBook.find( &#123; &quot;zipCode&quot; : &#123; $type : &quot;double&quot; &#125; &#125; )</span><br><span class="line">//返回结果</span><br><span class="line">&#123; &quot;_id&quot; : 2, &quot;address&quot; : &quot;156 Lunar Place&quot;, &quot;zip&quot; : 43339374 &#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>number</code>类型别名匹配BSON类型是<code>double``int</code>或<code>long</code>的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.addressBook.find( &#123; &quot;zipCode&quot; : &#123; $type : &quot;number&quot; &#125; &#125; )</span><br><span class="line">//返回结果</span><br><span class="line">&#123; &quot;_id&quot; : 2, address : &quot;156 Lunar Place&quot;, zipCode : 43339374 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 3, address : &quot;2324 Pluto Place&quot;, zipCode: NumberLong(3921412) &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 4, address : &quot;55 Saturn Ring&quot; , zipCode : 88602117 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>源数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">      &#123; &quot;_id&quot; : 1, name : &quot;Alice King&quot; , classAverage : 87.333333333333333 &#125;,</span><br><span class="line">      &#123; &quot;_id&quot; : 2, name : &quot;Bob Jenkins&quot;, classAverage : &quot;83.52&quot; &#125;,</span><br><span class="line">      &#123; &quot;_id&quot; : 3, name : &quot;Cathy Hart&quot;, classAverage: &quot;94.06&quot; &#125;,</span><br><span class="line">      &#123; &quot;_id&quot; : 4, name : &quot;Drew Williams&quot; , classAverage : 93 &#125;</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
<p>查询<code>classAverage</code>字段是BSON类型<code>string</code>或<code>double</code>的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.grades.find( &#123; &quot;classAverage&quot; : &#123; $type : [ 2 , 1 ] &#125; &#125; );</span><br><span class="line">//等价于</span><br><span class="line">db.grades.find( &#123; &quot;classAverage&quot; : &#123; $type : [ &quot;string&quot; , &quot;double&quot; ] &#125; &#125; );</span><br><span class="line">//返回结果</span><br><span class="line">&#123; &quot;_id&quot; : 1, name : &quot;Alice King&quot; , classAverage : 87.333333333333333 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 2, name : &quot;Bob Jenkins&quot;, classAverage : &quot;83.52&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 3, name : &quot;Cathy Hart&quot;, classAverage: &quot;94.06&quot; &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/30/2018-08-30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/30/2018-08-30/" itemprop="url">ps -ef、 ps aux、top、pidstat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-30T00:00:00+08:00">
                2018-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>linux中<code>ps -ef</code> 和 <code>ps aux</code>都支持用来查看进程快照，下面总结了他们的显示格式区别和各列的含义。(<code>ps -aux</code>已废弃，不要再用了)<br>推荐使用<code>ps -ef</code></p>
</blockquote>
<h3 id="ps-ef-标准的格式显示进程（System-V风格）"><a href="#ps-ef-标准的格式显示进程（System-V风格）" class="headerlink" title="ps -ef 标准的格式显示进程（System Ｖ风格）"></a>ps -ef 标准的格式显示进程（System Ｖ风格）</h3><table>
<thead>
<tr>
<th>UID</th>
<th>PID</th>
<th>PPID</th>
<th>C</th>
<th>STIME</th>
<th>TTY</th>
<th>TIME</th>
<th>CMD</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户</td>
<td>进程id</td>
<td>父进程id</td>
<td>cpu百分比</td>
<td>启动时间</td>
<td>所在终端</td>
<td>占用cpu时间</td>
<td>命令参数</td>
</tr>
<tr>
<td>root</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>06:50</td>
<td>?</td>
<td>00:00:10</td>
<td>/sbin/init</td>
</tr>
<tr>
<td>root</td>
<td>40</td>
<td>1</td>
<td>0</td>
<td>12:33</td>
<td>pts/0</td>
<td>00:00:03</td>
<td>/java/</td>
</tr>
</tbody>
</table>
<p>其中各列的内容意思如下</p>
<ul>
<li>UID    //用户ID、但输出的是用户名 </li>
<li>PID    //进程的ID </li>
<li>PPID    //父进程ID </li>
<li>C      //进程占用CPU的百分比 </li>
<li>STIME  //进程启动时间</li>
<li>TTY    //该进程在那个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。 </li>
<li>TIME  //进程使用cpu的时间</li>
<li>CMD    //命令的名称和参数</li>
</ul>
<h3 id="ps-ef展示启动时间"><a href="#ps-ef展示启动时间" class="headerlink" title="ps -ef展示启动时间"></a>ps -ef展示启动时间</h3><p>ps -ef、ps aux命令可以展示进程的大概信息，启动时间展示不完整，如果想得知进程的详细启动时间，怎么办呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux:</span><br><span class="line">$ ps -eo pid,lstart,cmd</span><br><span class="line"></span><br><span class="line">outPut:</span><br><span class="line">PID                  STARTED CMD</span><br><span class="line">    1 Mon Jun 19 21:31:08 2017 /sbin/init</span><br><span class="line">    2 Mon Jun 19 21:31:08 2017 [kthreadd]</span><br><span class="line">    3 Mon Jun 19 21:31:08 2017 [ksoftirqd/0]</span><br></pre></td></tr></table></figure>
<h3 id="ps-aux-BSD的格式来显示"><a href="#ps-aux-BSD的格式来显示" class="headerlink" title="ps aux BSD的格式来显示"></a>ps aux BSD的格式来显示</h3><table>
<thead>
<tr>
<th>USER</th>
<th>PID</th>
<th>%CPU</th>
<th>%MEM</th>
<th>VSZ</th>
<th>RSS</th>
<th>TTY</th>
<th>STAT</th>
<th>START</th>
<th>TIME</th>
<th>COMMAND</th>
</tr>
</thead>
<tbody>
<tr>
<td>root</td>
<td>1</td>
<td>0.0</td>
<td>1.2</td>
<td>19221</td>
<td>2989</td>
<td>?</td>
<td>S</td>
<td>12:20</td>
<td>00:09</td>
<td>/sbin/init</td>
</tr>
</tbody>
</table>
<p>同ps -ef 不同的有列有</p>
<ul>
<li>USER      //用户名 </li>
<li>%CPU      //进程占用的CPU百分比 </li>
<li>%MEM      //占用内存的百分比 </li>
<li>VSZ      //该进程使用的虚拟內存量（KB） </li>
<li>RSS      //该进程占用的固定內存量（KB）（驻留中页的数量） </li>
<li>STAT      //进程的状态 </li>
<li>START    //该进程被触发启动时间 </li>
<li>TIME      //该进程实际使用CPU运行的时间</li>
</ul>
<p>其中STAT状态位常见的状态字符有</p>
<ul>
<li>D      //无法中断的休眠状态（通常 IO 的进程）； </li>
<li>R      //正在运行可中在队列中可过行的； </li>
<li>S      //处于休眠状态； </li>
<li>T      //停止或被追踪； </li>
<li>W      //进入内存交换 （从内核2.6开始无效）； </li>
<li>X      //死掉的进程 （基本很少见）； </li>
<li>Z      //僵尸进程； </li>
<li>&lt;      //优先级高的进程 </li>
<li>N      //优先级较低的进程 </li>
<li>L      //有些页被锁进内存； </li>
<li>s      //进程的领导者（在它之下有子进程）； </li>
<li>l      //多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）； </li>
<li><ul>
<li>//位于后台的进程组；</li>
</ul>
</li>
</ul>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>使用示例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ top -p 4989</span><br><span class="line">$ top</span><br></pre></td></tr></table></figure>
<p>列说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PID,USER进程号，用户名。</span><br><span class="line"></span><br><span class="line">NI，nice，好看不好看。。动态修正CPU调度。范围（-20~19）。越大，cpu调度越一般，越小，cpu调度越偏向它。一般用于后台进程，调整也是往大了调，用来给前台进程让出CPU资源。</span><br><span class="line"></span><br><span class="line">PR：优先级，会有两种格式，一种是数字（默认20），一种是RT字符串。</span><br><span class="line"></span><br><span class="line">PR默认是20，越小，优先级越高。修改nice可以同时修改PR，测试过程：先开一个窗口，运行wc，另开一个窗口运行top，按N按照PID倒序排，按r输入要renice的PID，然后输入-19~20之间的值，可以看到NI变成输入的值，PR=PR+NI。修改NI得到PR的范围是0~39。优先级由高到低</span><br><span class="line"></span><br><span class="line">RT是real-time。只能用chrt -p (1~99) pid来修改。chrt -p 1 1234会将1234的PR改成-2，chrt -p 98 1234变成-99。chrt -p 99 1234会变成RT......只要chrt过，修改nice后PR不会再更改。修改chrt得到的PR范围是RT~-2。优先级由高到低</span><br><span class="line"></span><br><span class="line">VIRT：一个进程瞬时可以访问的所有内存总和大小，包括RES自己在使用的，共享的类库，和其他进程共享的内存，内存中的文件数据。共享的类库，一个大文件，只有一个程序片段被用到，这个文件会被 map到VIRT和SHR中，程序片段会在RES中。</span><br><span class="line"></span><br><span class="line">S：状态S -- Process Status. The status of the task which can be one of:</span><br><span class="line">D Uninterruptible sleep (usually IO)</span><br><span class="line">R Running or runnable (on run queue)</span><br><span class="line">S Interruptible sleep (waiting for an event to complete)</span><br><span class="line">T Stopped, either by a job control signal or because it is being traced.</span><br><span class="line">W paging (not valid since the 2.6.xx kernel)</span><br><span class="line">X dead (should never be seen)</span><br><span class="line">Z Defunct (&quot;zombie&quot;) process, terminated but not reaped by its parent.</span><br><span class="line"></span><br><span class="line">%CPU，总体CPU百分比，按H可以显示所有线程。8个核，从0~800%。</span><br><span class="line">%mem，RES占总MEM的百分比</span><br><span class="line">TIME+，自启动到现在占用的CPU时间。</span><br></pre></td></tr></table></figure>
<h3 id="pidstat-进程的信息"><a href="#pidstat-进程的信息" class="headerlink" title="pidstat 进程的信息"></a>pidstat 进程的信息</h3><p>使用示例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pidstat [ 选项 ] [ &lt;时间间隔&gt; ] [ &lt;次数&gt; ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># pid4989的cpu详细详细，每个1s打印一次，打印8次</span></span><br><span class="line">pidstat -u -p 4989 1 8</span><br><span class="line"><span class="comment"># 内存</span></span><br><span class="line">pidstat -r -p 4989 1 8</span><br><span class="line"><span class="comment"># 磁盘</span></span><br><span class="line">pidstat -d -p 4989 1 8</span><br><span class="line"><span class="comment"># 展示三者</span></span><br><span class="line">pidstat -urd -p 4989 1 8</span><br><span class="line"><span class="comment"># -h 在一行展示所有信息</span></span><br><span class="line">pidstat -urdh -p 4989 1 8</span><br><span class="line"><span class="comment"># 更多</span></span><br><span class="line">man pidstat</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-u：默认的参数，显示各个进程的cpu使用统计</span><br><span class="line">-r：显示各个进程的内存使用统计</span><br><span class="line">-d：显示各个进程的IO使用情况</span><br><span class="line">-p：指定进程号</span><br><span class="line">-w：显示每个进程的上下文切换情况</span><br><span class="line">-t：显示选择任务的线程的统计信息外的额外信息</span><br><span class="line">-T &#123; TASK | CHILD | ALL &#125;</span><br><span class="line">这个选项指定了pidstat监控的。TASK表示报告独立的task，CHILD关键字表示报告进程下所有线程统计信息。ALL表示报告独立的task和task下面的所有线程。</span><br><span class="line">注意：task和子线程的全局的统计信息和pidstat选项无关。这些统计信息不会对应到当前的统计间隔，这些统计信息只有在子线程kill或者完成的时候才会被收集。</span><br><span class="line">-V：版本号</span><br><span class="line">-h：在一行上显示了所有活动，这样其他程序可以容易解析。</span><br><span class="line">-I：在SMP环境，表示任务的CPU使用率/内核数量</span><br><span class="line">-l：显示命令名和所有参数</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/2018-08-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/2018-08-23/" itemprop="url">linux内存命令-top,free细解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T00:00:00+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="linux查看内存"><a href="#linux查看内存" class="headerlink" title="linux查看内存"></a>linux查看内存</h1><h2 id="1-top"><a href="#1-top" class="headerlink" title="1.top"></a>1.top</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>进程的CPU使用率排序：运行top命令后，键入大写P</li>
<li>内存使用率排序：运行top命令后，键入大写M</li>
</ul>
<p>各列的说明</p>
<ul>
<li>PID：进程的ID</li>
<li>USER：进程所有者</li>
<li>PR：进程的优先级别，越小越优先被执行</li>
<li>NInice：值</li>
<li>VIRT：进程占用的虚拟内存</li>
<li>RES：进程占用的物理内存</li>
<li>SHR：进程使用的共享内存</li>
<li>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</li>
<li>%CPU：进程占用CPU的使用率</li>
<li>%MEM：进程使用的物理内存和总内存的百分比</li>
<li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</li>
<li>COMMAND：进程启动命令名称</li>
</ul>
<h2 id="2-free"><a href="#2-free" class="headerlink" title="2.free"></a>2.free</h2><ul>
<li>total:总计物理内存的大小。</li>
<li>used:已使用多大。</li>
<li>free:可用有多少。</li>
<li>Shared:多个进程共享的内存总额。</li>
<li><p>Buffers/cached:磁盘缓存的大小。</p>
</li>
<li><p>区别：第二行(mem)的used/free与第三行(-/+ buffers/cache) used/free的区别。 这两个的区别在于使用的角度来看，第一行是从OS的角度来看，因为对于OS，buffers/cached 都是属于被使用，所以他的可用内存是434884KB,已用内存是3489800KB,</p>
</li>
<li>第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被回收。</li>
<li><strong>所以从应用程序的角度来说，可用内存 = 系统Free Memory + buffers + cached</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: free [-b|-k|-m|-g] [-l] [-o] [-t] [-s delay] [-c count] [-V]</span><br><span class="line">  -b,-k,-m,-g show output <span class="keyword">in</span> bytes, KB, MB, or GB</span><br><span class="line">  -l show detailed low and high memory statistics</span><br><span class="line">  -o use old format (no -/+buffers/cache line)</span><br><span class="line">  -t display total <span class="keyword">for</span> RAM + swap</span><br><span class="line">  -s update every [delay] seconds</span><br><span class="line">  -c update [count] <span class="built_in">times</span></span><br><span class="line">  -V display version information and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/22/2018-08-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/2018-08-12/" itemprop="url">Node.js Event Loop，Timers定时器和process.nextTick()</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T00:00:00+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是事件循环？"><a href="#什么是事件循环？" class="headerlink" title="什么是事件循环？"></a>什么是事件循环？</h2><p>事件循环是Node.js中实现非阻塞IO的机制，它通过及时的转发操作请求给系统内核来实现，尽管JavaScript是单线程的。<br>目前大部分的系统内核都是多线程的，可以后台同时处理多个操作请求。当某个请求处理完毕后，内核会通知node把对应的回调函数加入poll事件队列等待执行。我们稍后具体阐述这个流程。</p>
<h2 id="事件循环解释"><a href="#事件循环解释" class="headerlink" title="事件循环解释"></a>事件循环解释</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/22/2018-08-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/2018-08-22/" itemprop="url">Java线程安全容器小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T00:00:00+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HashMap线程安全"><a href="#HashMap线程安全" class="headerlink" title="HashMap线程安全"></a>HashMap线程安全</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用ConcurrentHashMap</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, LinkedHashSet&lt;String&gt;&gt; peerAssignHistoryMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, LinkedHashSet&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>支持获取的完全并发和更新的所期望可调整并发的哈希表。此类遵守与 Hashtable 相同的功能规范，并且包括对应于 Hashtable 的每个方法的方法版本。不过，尽管所有操作都是线程安全的，但获取操作不 必锁定，并且不 支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与 Hashtable 进行互操作，这取决于其线程安全，而与其同步细节无关。</p>
<p>获取操作（包括 get）通常不会受阻塞，因此，可能与更新操作交迭（包括 put 和 remove）。获取会影响最近完成的 更新操作的结果。对于一些聚合操作，比如 putAll 和 clear，并发获取可能只影响某些条目的插入和移除。类似地，在创建迭代器/枚举时或自此之后，Iterators 和 Enumerations 返回在某一时间点上影响哈希表状态的元素。它们不会 抛出 ConcurrentModificationException。不过，迭代器被设计成每次仅由一个线程使用。</p>
<p>这允许通过可选的 concurrencyLevel 构造方法参数（默认值为 16）来引导更新操作之间的并发，该参数用作内部调整大小的一个提示。表是在内部进行分区的，试图允许指示无争用并发更新的数量。因为哈希表中的位置基本上是随意的，所以实际的并发将各不相同。理想情况下，应该选择一个尽可能多地容纳并发修改该表的线程的值。使用一个比所需要的值高很多的值可能会浪费空间和时间，而使用一个显然低很多的值可能导致线程争用。对数量级估计过高或估计过低通常都会带来非常显著的影响。当仅有一个线程将执行修改操作，而其他所有线程都只是执行读取操作时，才认为某个值是合适的。此外，重新调整此类或其他任何种类哈希表的大小都是一个相对较慢的操作，因此，在可能的时候，提供构造方法中期望表大小的估计值是一个好主意。</p>
<p>此类及其视图和迭代器实现了 Map 和 Iterator 接口的所有可选 方法。</p>
<p>此类与 Hashtable 相似，但与 HashMap 不同，它不 允许将 null 用作键或值。</p>
<p>get与containsKey两个方法几乎完全一致：他们都没有使用锁，而是通过Unsafe对象的getObjectVolatile()方法提供的原子读语义，来获得Segment以及对应的链表，然后对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p>
<h5 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent"></a>putIfAbsent</h5><p>public V putIfAbsent(K key,<br>                     V value)<br>如果指定键已经不再与某个值相关联，则将它与给定值关联。这等价于：<br>   if (!map.containsKey(key))<br>      return map.put(key, value);<br>  else<br>       return map.get(key);<br>除了原子地执行此操作之外。<br>指定者：<br>接口 ConcurrentMap<k,v> 中的 putIfAbsent<br>参数：<br>key - 与指定值相关联的键<br>value - 与指定键相关联的值<br>返回：<br>以前与指定键相关联的值，如果该键没有映射关系，则返回 null<br>抛出：<br>NullPointerException - 如果指定键或值为 null</k,v></p>
<h4 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap"></a>Collections.synchronizedMap</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用Collections.synchronizedMap</span></span><br><span class="line"> Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure>
<p>返回由指定映射支持的同步（线程安全的）映射。为了保证按顺序访问，必须通过返回的映射完成 所有对底层实现映射的访问。<br>在返回映射的任意 collection 视图上进行迭代时，用户必须手工在返回的映射上进行同步：</p>
<p>  Map m = Collections.synchronizedMap(new HashMap());<br>      …<br>  Set s = m.keySet();  // Needn’t be in synchronized block<br>      …<br>  synchronized(m) {  // Synchronizing on m, not s!<br>      Iterator i = s.iterator(); // Must be in synchronized block<br>      while (i.hasNext())<br>          foo(i.next());<br>  }</p>
<p>不遵从此建议将导致无法确定的行为。</p>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><h3 id="Set线程安全"><a href="#Set线程安全" class="headerlink" title="Set线程安全"></a>Set线程安全</h3><h4 id="Collections-synchronizedSet"><a href="#Collections-synchronizedSet" class="headerlink" title="Collections.synchronizedSet"></a>Collections.synchronizedSet</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">返回指定 set 支持的同步（线程安全的）set。为了保证按顺序访问，必须通过返回的 set 完成对 所有底层实现 set 的访问。</span><br><span class="line">在返回的 set 上进行迭代时，用户必须手工在返回的 set 上进行同步：</span><br><span class="line"></span><br><span class="line">  Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet());</span><br><span class="line">      ...</span><br><span class="line">  <span class="keyword">synchronized</span>(s) &#123;</span><br><span class="line">      Iterator i = s.iterator(); <span class="comment">// Must be in the synchronized block</span></span><br><span class="line">      <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">          foo(i.next());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">不遵从此建议将导致无法确定的行为。</span><br></pre></td></tr></table></figure>
<h3 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h3><p>Java7中引入的非阻塞并发列表<br>参考：<a href="https://blog.csdn.net/sprita1/article/details/58609070" target="_blank" rel="noopener">https://blog.csdn.net/sprita1/article/details/58609070</a></p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>原子操作基本数据类型</p>
<p>以上两段代码，在使用Integer的时候，必须加上synchronized保证不会出现并发线程同时访问的情况，而在AtomicInteger中却不用加上synchronized，在这里AtomicInteger是提供原子操作的，下面就对这进行相应的介绍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//正常</span><br><span class="line">public class Sample1 &#123;</span><br><span class="line">    private static Integer count = 0;</span><br><span class="line">    synchronized public static void increment() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AtomicInteger</span><br><span class="line">public class Sample2 &#123;</span><br><span class="line">    private static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">    public static void increment() &#123;</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/26/2018-07-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/26/2018-07-26/" itemprop="url">node退出进程时,关闭mongo连接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-26T00:00:00+08:00">
                2018-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Shouldn’t we be closing the mongo connection somehow? It seems to be increasing with use in the mongod window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">var</span> gracefulShutdown;</span><br><span class="line"><span class="keyword">var</span> dbURI = <span class="string">'mongodb://localhost/mean-todo'</span>;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    dbURI = process.env.MONGOLAB_URI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mongoose.connect(dbURI);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CONNECTION EVENTS</span></span><br><span class="line">mongoose.connection.on(<span class="string">'connected'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Mongoose connected to '</span> + dbURI);</span><br><span class="line">&#125;);</span><br><span class="line">mongoose.connection.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Mongoose connection error: '</span> + err);</span><br><span class="line">&#125;);</span><br><span class="line">mongoose.connection.on(<span class="string">'disconnected'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Mongoose disconnected'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAPTURE APP TERMINATION / RESTART EVENTS</span></span><br><span class="line"><span class="comment">// To be called when process is restarted or terminated</span></span><br><span class="line">gracefulShutdown = <span class="function"><span class="keyword">function</span>(<span class="params">msg, callback</span>) </span>&#123;</span><br><span class="line">    mongoose.connection.close(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Mongoose disconnected through '</span> + msg);</span><br><span class="line">        callback();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// For nodemon restarts</span></span><br><span class="line">process.once(<span class="string">'SIGUSR2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gracefulShutdown(<span class="string">'nodemon restart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        process.kill(process.pid, <span class="string">'SIGUSR2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// For app termination</span></span><br><span class="line">process.on(<span class="string">'SIGINT'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gracefulShutdown(<span class="string">'app termination'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        process.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// For Heroku app termination</span></span><br><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gracefulShutdown(<span class="string">'Heroku app termination'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        process.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/13/2018-07-11-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/13/2018-07-11-3/" itemprop="url">SVN介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-13T00:00:00+08:00">
                2018-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SVN简介"><a href="#SVN简介" class="headerlink" title="SVN简介"></a>SVN简介</h1><h3 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h3><p>SVN是Subversion的简称，是一个开放源代码的版本控制系统，和git（分布式版本控制）比它采用了<strong>集中式版本控制</strong>，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。它管理者很多数据，这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul>
<li><strong>repository</strong>（源代码库）:源代码统一存放的地方</li>
<li><strong>Checkout</strong>（提取）:当你手上没有源代码的时候，你需要从repository checkout一份</li>
<li><strong>Commit</strong>（提交）:当你已经修改了代码，你就需要Commit到repository</li>
<li><strong>Update</strong> (更新):当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更</li>
<li><strong>Merge</strong> (合并): 当你有多个分支时，一般需要从trunk合并到分支，或分支合并到主干</li>
<li><strong>Trunk</strong> （主分支）: 主分支</li>
<li><strong>Branches</strong> (分支): 分支，开发一般需要新建一个branch，最后将代码合并到Trunk</li>
</ul>
<h3 id="与git比较"><a href="#与git比较" class="headerlink" title="与git比较"></a>与git比较</h3><p>git也是一个开源的分布式版本控制系统，是目前世界上最先进的分布式版本控制系统。相比较git有以下优势：</p>
<ul>
<li>git是分布式的,svn是集中式的。(最核心)</li>
<li>git是每个历史版本都存储完整的文件,便于恢复,svn是存储差异文件,历史版本不可恢复。(核心)</li>
<li>git可离线完成大部分操作,svn则不能</li>
<li>git分支和合并更强大</li>
<li>git有着更强的撤销修改和修改历史版本的能力</li>
<li>git速度更快,效率更高。</li>
</ul>
<p><strong>唯一弱点</strong>，Git 没有严格的权限管理控制，一般通过系统设置文件读写权限的方式来做权限控制。不过git的发展伴随着开源的发展，与github是亲兄弟。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>创建分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">svn cp -m <span class="string">"my new branch"</span> http://svn_server/xxx_repository/trunk http://svn_server/xxx_repository/branches/br_feature001</span><br></pre></td></tr></table></figure>
<p>删除分支或tags</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">svn rm http://svn_server/xxx_repository/branches/br_feature001</span><br><span class="line"></span><br><span class="line">svn rm http://svn_server/xxx_repository/tags/release-1.0</span><br></pre></td></tr></table></figure>
<p>checkout 到工作目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">svn co http://svn_server/xxx_repository/branches/br_feature001</span><br></pre></td></tr></table></figure>
<p>从主干合并到分支（主干更新后，想要拉取到我的分支）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> br_feature001</span><br><span class="line"></span><br><span class="line">svn merge http://svn_server/xxx_repository/trunk</span><br></pre></td></tr></table></figure>
<p>合并分支到主干（分支开发完毕后，需要合并到分支）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> trunk</span><br><span class="line"></span><br><span class="line">svn merge --reintegrate http://svn_server/xxx_repository/branches/br_feature001</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/12/2018-07-11-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/2018-07-11-2/" itemprop="url">mongo原子性和事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T00:00:00+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>关于mongodb原子性和事务的说明，大部分翻译自官方文档<code>(https://docs.mongodb.com/manual/tutorial)</code></p>
</blockquote>
<h1 id="原子性和事务"><a href="#原子性和事务" class="headerlink" title="原子性和事务"></a>原子性和事务</h1><p>在MongoDb中，写操作在<code>文档级别</code>是原子性的，即使该文档包含多个嵌入的子文档。</p>
<p>当一次写操作修改多个文档时，对每个文档的更新时原子性的，但整个写入操作不是原子性的，而且中间可能会插入多个其他操作。</p>
<h2 id="模拟事务"><a href="#模拟事务" class="headerlink" title="模拟事务"></a>模拟事务</h2><p>因为一个文档可以包含多个子文档，所以文档级别的原子性可以满足大部分的应用场景。如果你想把多个操作作为一个事务来处理，你可以实现一个<code>two-phase commit</code>。</p>
<p>然而，<code>two-phase commit</code>仅仅可以提供类事务语义。使用它可以保证数据的一致性，但是在<code>two-phase commit</code>或回滚进行时可能会返回中间数据。关于two-phase commit的更多信息，请看这里<a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" target="_blank" rel="noopener"> Perform Two Phase Commits</a></p>
<h2 id="并发控制-Concurrency-Control"><a href="#并发控制-Concurrency-Control" class="headerlink" title="并发控制  Concurrency Control"></a>并发控制  Concurrency Control</h2><p>并发控制可以保证多个应用运行时的一致性，避免导致数据不一致或数据冲突问题。</p>
<p>方法一是在一个有唯一数据值的字段上创建一个唯一索引<a href="https://docs.mongodb.com/manual/core/index-unique/#index-type-unique" target="_blank" rel="noopener">unique index</a>。这样可以防止插入或更新产生重复数据。在多个字段上创建唯一索引，来保证这多个字段组合值的唯一性。示例操作请看，<a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/#update-with-unique-indexes" target="_blank" rel="noopener">update() and Unique Index</a>, <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/#upsert-and-unique-index" target="_blank" rel="noopener">findAndModify() and Unique Index</a>。</p>
<p>方法二是，在查询条件上对指定字段的当前值进行判断。在写操作中，<code>two-phase commit</code>模式提供了一个变量，其中的查询条件包含了应用标识<a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/#phase-commits-concurrency" target="_blank" rel="noopener">application identifier</a>和写操作中数据的预期状态。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/12/2018-07-11-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/2018-07-11-1/" itemprop="url">nginx入门使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T00:00:00+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文综合介绍了Nginx的概念、特性、配置文件说明、常用命令等。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nginx是一个<strong>轻量级、高性能的HTTP和反向代理服务器</strong>，也是一个IMAP/POP3/SMTP服务器。它是由c语言开发，由俄罗斯人<code>伊戈尔·赛索耶夫</code>开发的，第一个公开版本发布于2004年10月4日。因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。其特点是<strong>占有内存少，并发能力强</strong>，事实上nginx是并发能力最好的web服务器，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，这点使 Nginx 尤其受到虚拟主机提供商的欢迎，能够支持高达 50,000 个并发连接数的响应。</p>
</li>
<li><p>作为反向代理和负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。</p>
</li>
<li><p>作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）。</p>
</li>
<li><p>Nginx 安装非常简单，配置文件非常简洁，Bugs非常少，资源占用低: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。</p>
</li>
</ul>
<h2 id="安装步骤（Mac）"><a href="#安装步骤（Mac）" class="headerlink" title="安装步骤（Mac）"></a>安装步骤（Mac）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew search nginx   <span class="comment"># 检查是否存在</span></span><br><span class="line">brew info nginx     <span class="comment"># 查看要安装的信息</span></span><br><span class="line">brew install nginx  <span class="comment"># 默认port 8080，访问：localhost:8080</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认的配置文件目录：<code>/usr/local/etc/nginx/nginx.conf</code></li>
<li>默认安装目录：<code>/usr/local/Cellar/nginx/1.13.9</code>，里面会有以nginx版本号命名的文件夹，这里就是安装的根目录。进入<code>1.13.9/bin</code>可以看到nginx的可执行文件。</li>
<li>在<code>1.13.9</code>目录下，还有一个名字为html的快捷方式文件夹，它指向的是<code>/usr/local/var/www</code>目录，该目录下包含<code>50x.html</code>和<code>index.html</code>文件，是nginx服务器默认的显示页面。当它不存在时，访问出现<code>403错误</code>。</li>
<li>使用<code>nginx</code>命令后台启动服务器</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx            <span class="comment">#打开 nginx</span></span><br><span class="line">nginx -s reload  <span class="comment">#重新加载配置</span></span><br><span class="line">nginx -s reopen  <span class="comment">#重启nginx</span></span><br><span class="line">nginx -s stop    <span class="comment">#停止nginx</span></span><br><span class="line">nginx -s quit    <span class="comment">#退出nginx</span></span><br><span class="line">nginx -t         <span class="comment">#测试配置是否有语法错误</span></span><br></pre></td></tr></table></figure>
<h2 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行用户</span></span><br><span class="line">user nobody;</span><br><span class="line"><span class="comment">#启动进程,通常设置成和cpu的数量相等</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#全局错误日志及PID文件</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#工作模式及连接数上限</span></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#epoll是多路复用IO(I/O Multiplexing)中的一种方式,</span></span><br><span class="line">    <span class="comment">#仅用于linux2.6以上内核,可以大大提高nginx的性能</span></span><br><span class="line">    use   epoll; </span><br><span class="line"></span><br><span class="line">    <span class="comment">#单个后台worker process进程的最大并发链接数    </span></span><br><span class="line">    worker_connections  1024;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 并发总数是 worker_processes 和 worker_connections 的乘积</span></span><br><span class="line">    <span class="comment"># 即 max_clients = worker_processes * worker_connections</span></span><br><span class="line">    <span class="comment"># 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么</span></span><br><span class="line">    <span class="comment"># 为什么上面反向代理要除以4，应该说是一个经验值</span></span><br><span class="line">    <span class="comment"># 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000</span></span><br><span class="line">    <span class="comment"># worker_connections 值的设置跟物理内存大小有关</span></span><br><span class="line">    <span class="comment"># 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span></span><br><span class="line">    <span class="comment"># 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span></span><br><span class="line">    <span class="comment"># 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span></span><br><span class="line">    <span class="comment"># $ cat /proc/sys/fs/file-max</span></span><br><span class="line">    <span class="comment"># 输出 34336</span></span><br><span class="line">    <span class="comment"># 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span></span><br><span class="line">    <span class="comment"># 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span></span><br><span class="line">    <span class="comment"># 使得并发总数小于操作系统可以打开的最大文件数目</span></span><br><span class="line">    <span class="comment"># 其实质也就是根据主机的物理CPU和内存进行配置</span></span><br><span class="line">    <span class="comment"># 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span></span><br><span class="line">    <span class="comment"># ulimit -SHn 65535</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">#设定mime类型,类型由mime.type文件定义</span></span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    <span class="comment">#设定日志格式</span></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span></span><br><span class="line">    <span class="comment">#对于普通应用，必须设为 on,</span></span><br><span class="line">    <span class="comment">#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span></span><br><span class="line">    <span class="comment">#以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span></span><br><span class="line">    sendfile     on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#连接超时时间</span></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启gzip压缩</span></span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable <span class="string">"MSIE [1-6]."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设定请求缓冲</span></span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#设定虚拟主机配置</span></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#侦听80端口</span></span><br><span class="line">        listen    80;</span><br><span class="line">        <span class="comment">#定义使用 www.nginx.cn访问</span></span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义服务器的默认网站根目录位置</span></span><br><span class="line">        root html;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#设定本虚拟主机的访问日志</span></span><br><span class="line">        access_log  logs/nginx.access.log  main;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#默认请求</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#定义首页索引文件的名称</span></span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义错误提示页面</span></span><br><span class="line">        error_page   500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#静态文件，nginx自己处理</span></span><br><span class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#过期30天，静态文件不怎么更新，过期可以设大一点，</span></span><br><span class="line">            <span class="comment">#如果频繁更新，则可以设置得小一点。</span></span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span></span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#禁止访问 .htxxx 文件</span></span><br><span class="line">            location ~ /.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/2018-07-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/2018-07-11/" itemprop="url">node.js错误类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-11T00:00:00+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文大致介绍了node.js中四种常见的错误类型，列举了常见的标准错误，比如<code>SyntaxError``ReferenceError</code>等等，然后列举了自定义error和assertError的实例及错误的捕获和处理的几种方式。</p>
</blockquote>
<p>四种错误类型：</p>
<h2 id="1-标准错误"><a href="#1-标准错误" class="headerlink" title="1.标准错误"></a>1.标准错误</h2><p>这些错误在开发中都很常见，错误类型的有</p>
<ul>
<li><code>SyntaxError</code> js语法错误</li>
<li><code>ReferenceError</code> 使用未定义变量时抛出</li>
<li><code>RangeError</code> 当一个值不在指定范围内时抛出</li>
<li><code>TypeError</code> 传递错误的参数类型时抛出</li>
<li><code>EvalError</code> 调用<code>eval()</code>失败时抛出</li>
<li><code>URIError</code> 当一个全局的URI函数被错误使用时抛出</li>
</ul>
<h2 id="2-自定义错误"><a href="#2-自定义错误" class="headerlink" title="2.自定义错误"></a>2.自定义错误</h2><p>使用Error构造函数抛出错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">if(a&lt;2)&#123;</span><br><span class="line">  throw Error(&quot;less than 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;last&apos;)  //这里不会在执行</span><br><span class="line"></span><br><span class="line">/Users/shaoc/svn/npmtest/src/tableheader/b.js:4</span><br><span class="line">  throw Error(&quot;less than 2&quot;);</span><br><span class="line">  ^</span><br><span class="line"></span><br><span class="line">Error: less than 2</span><br><span class="line">    at Error (native)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/shaoc/svn/npmtest/src/tableheader/b.js:4:9)</span><br><span class="line">    at Module._compile (module.js:570:32)</span><br><span class="line">    at Object.Module._extensions..js (module.js:579:10)</span><br><span class="line">    at Module.load (module.js:487:32)</span><br><span class="line">    at tryModuleLoad (module.js:446:12)</span><br><span class="line">    at Function.Module._load (module.js:438:3)</span><br><span class="line">    at Module.runMain (module.js:604:10)</span><br><span class="line">    at run (bootstrap_node.js:394:7)</span><br><span class="line">    at startup (bootstrap_node.js:149:9)</span><br></pre></td></tr></table></figure>
<h2 id="3-断言错误"><a href="#3-断言错误" class="headerlink" title="3.断言错误"></a>3.断言错误</h2><p>当代码违反业务逻辑时，由<code>assert</code>模块触发 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">"assert"</span>)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">assert(a &gt; <span class="number">10</span>, <span class="string">"a不能小于10"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'last'</span>)</span><br><span class="line">assert.js:<span class="number">85</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> assert.AssertionError(&#123;</span><br><span class="line">  ^</span><br><span class="line">AssertionError: a不能小于<span class="number">10</span></span><br><span class="line">    at <span class="built_in">Object</span>.&lt;anonymous&gt; (<span class="regexp">/Users/</span>shaoc/svn/npmtest/src/tableheader/b.js:<span class="number">5</span>:<span class="number">1</span>)</span><br><span class="line">    at Module._compile (<span class="built_in">module</span>.js:<span class="number">570</span>:<span class="number">32</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.Module._extensions..js (<span class="built_in">module</span>.js:<span class="number">579</span>:<span class="number">10</span>)</span><br><span class="line">    at Module.load (<span class="built_in">module</span>.js:<span class="number">487</span>:<span class="number">32</span>)</span><br><span class="line">    at tryModuleLoad (<span class="built_in">module</span>.js:<span class="number">446</span>:<span class="number">12</span>)</span><br><span class="line">    at <span class="built_in">Function</span>.Module._load (<span class="built_in">module</span>.js:<span class="number">438</span>:<span class="number">3</span>)</span><br><span class="line">    at Module.runMain (<span class="built_in">module</span>.js:<span class="number">604</span>:<span class="number">10</span>)</span><br><span class="line">    at run (bootstrap_node.js:<span class="number">394</span>:<span class="number">7</span>)</span><br><span class="line">    at startup (bootstrap_node.js:<span class="number">149</span>:<span class="number">9</span>)</span><br><span class="line">    at bootstrap_node.js:<span class="number">509</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="4-系统错误"><a href="#4-系统错误" class="headerlink" title="4.系统错误"></a>4.系统错误</h2><p>系统错误是对JavaScript错误Error对象的一个扩展，它们表示程序能够处理的操作错误，这些错误信息都是在系统级别生成的。系统错误实例中除Error实例中的属性外，还包括以下几个属性：</p>
<p>1、error.syscall - 一个表示失败的系统调用信息的字符串<br>2、error.errno - 一个整数的错误码<br>3、error.code - 表示错误字符串，通常是大写字母E开头</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li>node可以使用try catch 捕获异常，但是没有办法捕获到异步调用中发生的异常</li>
<li>使用错误优先的回调函数，function(err, data) //优先处理错误信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">fs.readFile(&apos;一个不存在的文件&apos;, (err, data) =&gt; &#123;</span><br><span class="line"> if (err) &#123;</span><br><span class="line">  console.error(&apos;读取文件错误&apos;, err);</span><br><span class="line">  return;</span><br><span class="line"> &#125;</span><br><span class="line"> // 其它处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用事件机制捕获异常</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const connection = net.connect(&apos;localhost&apos;);</span><br><span class="line"> </span><br><span class="line">// 为stream添加一个 &apos;error&apos; 事件处理器:</span><br><span class="line">connection.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line"> // 如果连接被服务器重置或连接不到指定的服务器</span><br><span class="line"> // 或其它连接错误时，错误会被传递到这里</span><br><span class="line"> console.error(err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.pipe(process.stdout);</span><br><span class="line"></span><br><span class="line">//全局</span><br><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">  log.app.error(&quot;Caught exception:-----&gt;&quot;, err);</span><br><span class="line">  process.exit(8);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用domain</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/2018-05-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/2018-05-15/" itemprop="url">node.js中的module.exports和exports</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T00:00:00+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前对<code>exports</code>和<code>module.exports</code>一直存在疑惑，知道<code>exports</code>使用不当可能会导致问题，所以一直使用<code>module.exports</code>, 理解没有深入。通过阅读官方文档，对它们的区别、联系和使用注意事项做一个总结。</p>
<h2 id="翻译自官方文档"><a href="#翻译自官方文档" class="headerlink" title="翻译自官方文档"></a>翻译自官方文档</h2><p><a href="https://nodejs.org/docs/latest/api/modules.html#modules_module_exports" target="_blank" rel="noopener">官方文档</a><br>在node每个模块中，都有一个<code>module</code>变量保存着对当前模块的引用。为了方便，<code>module.exports</code>也可以通过<code>exports</code>全局模块来访问。<code>module</code>不是全局的，对每一个模块来说，它都是一个本地变量。</p>
<h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><p><code>module.exports</code>对象，是由模块系统创建的。当你想在其他类中引用一个模块时，可以用它来实现，通过将你要导出的对象赋值给<code>module.exports</code>。千万注意，本地的<code>exports</code>对象仅仅在初始的时候保存着对<code>module.exports</code>的引用，有些时候可能不会得到你想要的结果。<br>举个例子来说，创建一个a.js的模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="comment">// Do some work, and after some time emit</span></span><br><span class="line"><span class="comment">// the 'ready' event from the module itself.</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports.emit(<span class="string">'ready'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>然后在另一个模块，我们可以引入它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">a.on(<span class="string">'ready'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'module "a" is ready'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>请注意，对<code>module.exports</code>的复制必须是立即执行的，不可以在任何回调中进行导出。比如，下面这样无效：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123; <span class="attr">a</span>: <span class="string">'hello'</span> &#125;;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="exports-shortcut"><a href="#exports-shortcut" class="headerlink" title="exports shortcut"></a>exports shortcut</h3><p><code>exports</code>变量仅在模块的文件作用域内有效，在初始时，它保存着对<code>module.exports</code>的应用。所以有些时候，<code>module.exports.f = ...</code>可以简写为<code>exports.f = ....</code>。但是，千万注意，在对它进行重新赋值之后，它将不再绑定到<code>module.exports</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.hello = <span class="literal">true</span>; <span class="comment">// Exported from require of module</span></span><br><span class="line">exports = &#123; <span class="attr">hello</span>: <span class="literal">false</span> &#125;;  <span class="comment">// Not exported, only available in the module</span></span><br></pre></td></tr></table></figure>
<p><strong>当对<code>module.exports</code>重新赋值为新对象的时候，最好把<code>exports</code>也重新赋值</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = exports = <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... etc.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="require实现"><a href="#require实现" class="headerlink" title="require实现"></a>require实现</h3><p>为了更好的解释这一点，下面是<code>require()</code>方法的简要实现，它和实际的实现基本原理相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"><span class="regexp">/* ... */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">  (<span class="function">(<span class="params"><span class="built_in">module</span>, exports</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Module code here. In this example, define a function.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">someFunc</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    exports = someFunc;</span><br><span class="line">    <span class="comment">// At this point, exports is no longer a shortcut to module.exports, and</span></span><br><span class="line">    <span class="comment">// this module will still export an empty default object.</span></span><br><span class="line">    <span class="built_in">module</span>.exports = someFunc;</span><br><span class="line">    <span class="comment">// At this point, the module will now export someFunc, instead of the</span></span><br><span class="line">    <span class="comment">// default object.</span></span><br><span class="line">  &#125;)(<span class="built_in">module</span>, <span class="built_in">module</span>.exports);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>在一个模块内，<code>exports</code>仅仅是对<code>module.exports</code>的引用</li>
<li>在未对<code>exports</code>重新赋值前，可以使用<code>exports.myfun=function(){}</code>的形式导出，但请不要使用<code>exports = { }</code> 的形式</li>
<li>整对象导出时，尽量使用<code>module.exports=exports= function Constructor(){ }</code>的形式，避免出现漏洞</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/2018-05-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/2018-05-14/" itemprop="url">node.js异步框架thenjs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T00:00:00+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中存在大量的es5回调的代码，而且生产环境对原生Promise、awati/async 支持不够好，所以使用then.js作为异步解决方案，避免回调地狱的问题，也能兼容老代码。本文简要介绍了then.js异步框架的特点、安装和基本用法。</p>
<h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><p>一个解决js异步回调问题的方案，它可以将“回调地狱”处理成并列的then链，方便代码的阅读和维护。<br><a href="https://www.npmjs.com/package/thenjs" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>可以像标准的 Promise 那样，把N多异步回调函数写成一个长长的 then 链，并且比 Promise 更简洁自然。因为如果使用标准 Promise 的 then 链，其中的异步函数都必须转换成 Promise，Thenjs 则无需转换，像使用 callback 一样执行异步函数即可。</p>
</li>
<li><p>强大的 Error 机制，可以捕捉任何同步或异步的异常错误，甚至是位于异步函数中的语法错误。并且捕捉的错误任君处置。</p>
</li>
<li><p>开启debug模式，可以把每一个then链运行结果输出到debug函数（未定义debug函数则用 console.log），方便调试。</p>
</li>
</ul>
<h2 id="安装-amp-使用"><a href="#安装-amp-使用" class="headerlink" title="安装&amp;使用"></a>安装&amp;使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install thenjs --save</span><br><span class="line">var Thenjs = require(&quot;thenjs&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Thenjs(<span class="function"><span class="keyword">function</span> (<span class="params">cont</span>) </span>&#123;</span><br><span class="line">  cont(<span class="literal">null</span>, result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">cont</span>) </span>&#123;</span><br><span class="line">  cont(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!'</span>), <span class="number">123</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.fin(<span class="function"><span class="keyword">function</span> (<span class="params">cont, error, result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error, result);</span><br><span class="line">  cont();</span><br><span class="line">&#125;)</span><br><span class="line">.each([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">cont, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do sth with value</span></span><br><span class="line">  cont(<span class="literal">null</span>);  <span class="comment">// 并行执行队列任务，把队列 list 中的每一个值输入到 task 中运行</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">cont, result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  cont();</span><br><span class="line">&#125;)</span><br><span class="line">.series([ <span class="comment">// 串行执行队列任务</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">cont</span>) </span>&#123; task(<span class="number">88</span>, cont); &#125;, <span class="comment">// 队列第一个是异步任务</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">cont</span>) </span>&#123; cont(<span class="literal">null</span>, <span class="number">99</span>); &#125; <span class="comment">// 第二个是同步任务</span></span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">cont, result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  cont(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span> (<span class="params">cont, error</span>) </span>&#123; <span class="comment">// 通常应该在链的最后放置一个 `fail` 方法收集异常</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'DEMO END!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="两种方式定义"><a href="#两种方式定义" class="headerlink" title="两种方式定义"></a>两种方式定义</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Thenjs().then(<span class="function"><span class="keyword">function</span>(<span class="params">cont</span>) </span>&#123; </span><br><span class="line">    cont(<span class="literal">null</span>); </span><br><span class="line">&#125;);</span><br><span class="line">Thenjs(<span class="function"><span class="keyword">function</span>(<span class="params">cont, result</span>) </span>&#123; </span><br><span class="line">    cont(result); </span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">cont, result</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Thenjs-each-array-iterator"><a href="#Thenjs-each-array-iterator" class="headerlink" title="Thenjs.each(array, iterator)"></a>Thenjs.each(array, iterator)</h3><p>将 array 中的值应用于 iterator 函数（同步或异步），并行执行。返回一个新的 Thenjs 对象。<br>返回结果result是一个数组，包含每个cont返回的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Thenjs.each([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">cont, value</span>) </span>&#123;</span><br><span class="line">  task(value * <span class="number">2</span>, cont);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">cont, result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Thenjs-eachSeries-array-iterator"><a href="#Thenjs-eachSeries-array-iterator" class="headerlink" title="Thenjs.eachSeries(array, iterator)"></a>Thenjs.eachSeries(array, iterator)</h3><p>同上，串行执行</p>
<h3 id="Thenjs-parallel-tasksArray"><a href="#Thenjs-parallel-tasksArray" class="headerlink" title="Thenjs.parallel(tasksArray)"></a>Thenjs.parallel(tasksArray)</h3><p>tasksArray 是一个函数（同步或异步）数组，<strong>并行执行</strong>。返回一个新的 Thenjs 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Thenjs.parallel([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">cont</span>) </span>&#123; task(<span class="number">88</span>, cont); &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">cont</span>) </span>&#123; cont(<span class="literal">null</span>, <span class="number">99</span>); &#125;</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">cont, result</span>) </span>&#123;  <span class="comment">//result 是返回结果的数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Thenjs-series-tasksArray"><a href="#Thenjs-series-tasksArray" class="headerlink" title="Thenjs.series(tasksArray)"></a>Thenjs.series(tasksArray)</h3><p>同上，接受函数数组参数，<strong>串行执行</strong></p>
<h3 id="Thenjs-parallelLimit-tasksArray-limit"><a href="#Thenjs-parallelLimit-tasksArray-limit" class="headerlink" title="Thenjs.parallelLimit(tasksArray, limit)"></a>Thenjs.parallelLimit(tasksArray, limit)</h3><p>同parallel，并行执行，不过限制最大并发数为limit</p>
<h3 id="Thenjs-eachLimit-array-iterator-limit"><a href="#Thenjs-eachLimit-array-iterator-limit" class="headerlink" title="Thenjs.eachLimit(array, iterator, limit)"></a>Thenjs.eachLimit(array, iterator, limit)</h3><p>同each，并行执行，限制最大并发数为limit</p>
<h3 id="Thenjs-prototype-then-successHandler-errorHandler"><a href="#Thenjs-prototype-then-successHandler-errorHandler" class="headerlink" title="Thenjs.prototype.then(successHandler, [errorHandler])"></a>Thenjs.prototype.then(successHandler, [errorHandler])</h3><p>如果上一链正确，则进入 successHandler 执行，否则进入 errorHandler 执行。返回一个新的 Thenjs 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Thenjs(<span class="function"><span class="keyword">function</span> (<span class="params">cont</span>) </span>&#123;</span><br><span class="line">  task(<span class="number">10</span>, cont);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">cont, arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">cont, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Thenjs-prototype-finally-finallyHandler"><a href="#Thenjs-prototype-finally-finallyHandler" class="headerlink" title="Thenjs.prototype.finally(finallyHandler)"></a>Thenjs.prototype.finally(finallyHandler)</h3><p>别名<code>fin</code><br>无论上一链是否存在 error，均进入 finallyHandler 执行，等效于 .then(successHandler, errorHandler)。返回一个新的 Thenjs 对象。</p>
<h3 id="Thenjs-prototype-fail-errorHandler"><a href="#Thenjs-prototype-fail-errorHandler" class="headerlink" title="Thenjs.prototype.fail(errorHandler)"></a>Thenjs.prototype.fail(errorHandler)</h3><p>fail 用于捕捉 error，如果在它之前的任意一个链上产生了 error，并且未被 then, finally 等捕获，则会跳过中间链，直接进入 fail。返回一个新的 Thenjs 对象。</p>
<h3 id="prototype也有each-eachSeries-parallel-series"><a href="#prototype也有each-eachSeries-parallel-series" class="headerlink" title="prototype也有each eachSeries parallel series"></a>prototype也有each eachSeries parallel series</h3><p>Thenjs.prototype.each(array, iterator)<br>参数类似 Thenjs.each，返回一个新的 Thenjs 对象。</p>
<p>不同在于，参数可省略，如果没有参数，则会查找上一个链的输出结果作为参数，即上一个链可以这样 cont(null, array, iterator) 传输参数到each。下面三个队列方法行为类似。</p>
<p>Thenjs.prototype.eachSeries(array, iterator)<br>参数类似 Thenjs.eachSeries，返回一个新的 Thenjs 对象。</p>
<p>Thenjs.prototype.parallel(tasksArray)<br>参数类似 Thenjs.parallel，返回一个新的 Thenjs 对象。</p>
<p>Thenjs.prototype.series(tasksArray)<br>参数类似 Thenjs.series，返回一个新的 Thenjs 对象。</p>
<p>Thenjs.prototype.parallelLimit(tasksArray, limit)<br>参数类似 Thenjs.parallelLimit，返回一个新的 Thenjs 对象。</p>
<p>Thenjs.prototype.eachLimit(array, iterator, limit)<br>参数类似 Thenjs.eachLimit，返回一个新的 Thenjs 对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/05/2017-12-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/05/2017-12-05/" itemprop="url">设计模式6原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T00:00:00+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计模式6原则"><a href="#设计模式6原则" class="headerlink" title="设计模式6原则"></a>设计模式6原则</h1><p>参考自csdn：<a href="https://www.cnblogs.com/dolphin0520/p/3919839.html" target="_blank" rel="noopener">设计模式之六大原则</a></p>
<h2 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1 单一职责原则 SRP"></a>1 单一职责原则 SRP</h2><blockquote>
<p>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>
</blockquote>
<p>  单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>
<p>==单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。==</p>
<h2 id="2-开闭原则-OCP"><a href="#2-开闭原则-OCP" class="headerlink" title="2 开闭原则 OCP"></a>2 开闭原则 OCP</h2><p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。</p>
<blockquote>
<p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
</blockquote>
<p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p>
<p>为了满足开闭原则，==需要对系统进行抽象化设计，抽象化是开闭原则的关键==。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。==如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。==</p>
<h2 id="3-里氏替换原则-LSP"><a href="#3-里氏替换原则-LSP" class="headerlink" title="3 里氏替换原则 LSP"></a>3 里氏替换原则 LSP</h2><blockquote>
<p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p>==通俗的讲：“老鼠的儿子会打洞”==</p>
<p>里氏代换原则告诉我们，==在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象==。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p>
<p>例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。</p>
<p>==里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。==</p>
<p>在使用里氏代换原则时需要注意如下几个问题：</p>
<p>(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p>
<p>(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p>
<p>(3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p>
<h2 id="4-依赖倒置原则-DIP"><a href="#4-依赖倒置原则-DIP" class="headerlink" title="4 依赖倒置原则  DIP"></a>4 依赖倒置原则  DIP</h2><blockquote>
<p>依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
</blockquote>
<p>==依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。==</p>
<p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p>
<p>在实现依赖倒转原则时，==我们需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入(DependencyInjection, DI)</strong>的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。==</p>
<h2 id="5-接口隔离原则-ISP"><a href="#5-接口隔离原则-ISP" class="headerlink" title="5 接口隔离原则 ISP"></a>5 接口隔离原则 ISP</h2><blockquote>
<p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
</blockquote>
<p> 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。==每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。==这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p>
<p>(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做==“角色隔离原则”==。</p>
<p>(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指==接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口==。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</p>
<h2 id="6-迪米特法则-LOD"><a href="#6-迪米特法则-LOD" class="headerlink" title="6 迪米特法则 LOD"></a>6 迪米特法则 LOD</h2><p>==<strong>迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</strong>==</p>
<p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。==迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。==</p>
<p>迪米特法则还有几种定义形式，包括：<strong>不要和“陌生人”说话、只与你的直接朋友通信等</strong>。</p>
<p>迪米特法则要求我们在设计系统时，==应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。==</p>
<p>在将迪米特法则运用到系统设计中时，要注意下面的几点：==在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。==</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/02/2017-08-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/2017-08-02/" itemprop="url">正则表达式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T00:00:00+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正则表达式总结"><a href="#正则表达式总结" class="headerlink" title="正则表达式总结"></a>正则表达式总结</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接实例化</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern [, flags]);</span><br><span class="line"><span class="comment">// 隐式创建(推荐)</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。</p>
</li>
<li><p>参数 [, flags] 是一个可选的字符串，包含属性 “g”（global ）、”i” （ignoreCase）和 “m”（multiline）。</p>
</li>
</ul>
<h3 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h3><p>在正则表达式中，使用括号括起来的内容是一个<strong>子表达式</strong>，子表达式匹配到的内容会被系统捕获至缓冲区，使用<strong>\n（n：数字）</strong>来反向引用系统的第n号缓冲区的内容。</p>
<p><strong>使用场景：后面的内容要求与前面的一致，可以使用子表达式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找连续相同的四个数字</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"1212ab45677778cd"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d)\1\1\1/gi</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"><span class="comment">// OUTPUT:7777</span></span><br></pre></td></tr></table></figure>
<h3 id="方括号（字符簇）"><a href="#方括号（字符簇）" class="headerlink" title="方括号（字符簇）"></a>方括号（字符簇）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Is this all there is?"</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/[a-h]/g</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(patt1));</span><br><span class="line"><span class="comment">// OUTPUT:h,a,h,e,e</span></span><br></pre></td></tr></table></figure>
<p>方括号    作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[abc]	查找方括号之间的任何字符。</span><br><span class="line">[^abc]查找任何不在方括号之间的字符。</span><br><span class="line">[0-9]	查找任何从 0 至 9 的数字。同 \d</span><br><span class="line">[a-z]	查找任何从小写 a 到小写 z 的字符。</span><br><span class="line">[A-Z]	查找任何从大写 A 到大写 Z 的字符。</span><br><span class="line">[A-z]	查找任何从大写 A 到小写 z 的字符。</span><br><span class="line">[0-9a-zA-Z]	查找0-9,a-z,A-Z</span><br></pre></td></tr></table></figure>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元字符（Metacharacter）是拥有特殊含义的字符：</span><br><span class="line">元字符 | 作用</span><br><span class="line">—|—</span><br><span class="line">\ | 转义符 （、）、/、\</span><br><span class="line">| | 选择匹配符，可以匹配多个规则</span><br><span class="line">. | 查找单个字符，除了换行和行结束符。</span><br><span class="line">\w | 查找单词字符。字符 ( 字母 ，数字，下划线_ )</span><br><span class="line">\W | 查找非单词字符。</span><br><span class="line">\d | 查找数字。</span><br><span class="line">\D | 查找非数字字符。</span><br><span class="line">\s | 查找空白字符。空格</span><br><span class="line">\S | 查找非空白字符。</span><br><span class="line">\b | 匹配单词边界。</span><br><span class="line">\B | 匹配非单词边界。</span><br><span class="line">\0 | 查找 NUL 字符。</span><br><span class="line">\n | 查找换行符。</span><br><span class="line">\f | 查找换页符。</span><br><span class="line">\r | 查找回车符。</span><br><span class="line">\t | 查找制表符。</span><br><span class="line">\v | 查找垂直制表符。</span><br><span class="line">\xxx | 查找以八进制数 xxx 规定的字符。</span><br><span class="line">\xdd | 查找以十六进制数 dd 规定的字符。</span><br><span class="line">\uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。</span><br></pre></td></tr></table></figure>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">量词	作用</span><br><span class="line">n+	匹配任何包含至少一个 n 的字符串。同 &#123;1,&#125;</span><br><span class="line">n*	匹配任何包含零个或多个 n 的字符串。同 &#123;0,&#125;</span><br><span class="line">n?	匹配任何包含零个或一个 n 的字符串。同 &#123;0,1&#125;</span><br><span class="line">n&#123;X&#125;	匹配包含 X 个 n 的序列的字符串。</span><br><span class="line">n&#123;X,Y&#125;	匹配包含 X 至 Y 个 n 的序列的字符串。</span><br><span class="line">n&#123;X,&#125;	匹配包含至少 X 个 n 的序列的字符串。</span><br><span class="line">n$	匹配任何结尾为 n 的字符串。</span><br><span class="line">^n	匹配任何开头为 n 的字符串。注意 /[^a] / 和 /^ [a]/是不一样的，前者是排除的，后者是代表首位。</span><br><span class="line">(?=n)	匹配任何其后紧接指定字符串 n 的字符串。正向预查</span><br><span class="line">(?!n)	匹配任何其后没有紧接指定字符串 n 的字符串。反向预查</span><br></pre></td></tr></table></figure>
<h2 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h2><h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p><code>test()</code> 方法检索字符串中是否存在指定的值。返回值是 true 或 false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt1 = new RegExp(&apos;e&apos;);</span><br><span class="line">console.log(patt1.test(&apos;some text&apos;));</span><br><span class="line">// OUTPUT:true</span><br><span class="line">var patt2 = new RegExp(&apos;ee&apos;);</span><br><span class="line">console.log(patt2.test(&apos;some text&apos;));</span><br><span class="line">// OUTPUT:false</span><br></pre></td></tr></table></figure>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><code>exec()</code> 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> patt1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'e'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(patt1.exec(<span class="string">'some text'</span>));</span><br><span class="line"><span class="comment">// OUTPUT:e</span></span><br><span class="line"><span class="keyword">var</span> patt2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ee'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(patt2.exec(<span class="string">'some text'</span>));</span><br><span class="line"><span class="comment">// OUTPUT:null</span></span><br></pre></td></tr></table></figure>
<h3 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h3><p><code>compile()</code> 既可以改变检索模式，也可以添加或删除第二个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> patt1=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"e"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(patt1.test(<span class="string">"The best things in life are free"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 改变了检索模式</span></span><br><span class="line">patt1.compile(<span class="string">"eee"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(patt1.test(<span class="string">"The best things in life are free"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h2><h3 id="search-检索与正则表达式相匹配的值，输出所在位置。"><a href="#search-检索与正则表达式相匹配的值，输出所在位置。" class="headerlink" title="search 检索与正则表达式相匹配的值，输出所在位置。"></a>search 检索与正则表达式相匹配的值，输出所在位置。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Visit W3School!"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/W3School/</span>))</span><br><span class="line"><span class="comment">// OUTPUT:6</span></span><br></pre></td></tr></table></figure>
<h3 id="match-找到一个或多个正则表达式的匹配。"><a href="#match-找到一个或多个正则表达式的匹配。" class="headerlink" title="match 找到一个或多个正则表达式的匹配。"></a>match 找到一个或多个正则表达式的匹配。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"1 plus 2 equal 3"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/\d+/g</span>))</span><br><span class="line"><span class="comment">// OUTPUT:1,2,3</span></span><br></pre></td></tr></table></figure>
<h3 id="replace-替换与正则表达式匹配的子串。"><a href="#replace-替换与正则表达式匹配的子串。" class="headerlink" title="replace 替换与正则表达式匹配的子串。"></a>replace 替换与正则表达式匹配的子串。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Visit Microsoft!"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/Microsoft/</span>, <span class="string">"W3School"</span>));</span><br><span class="line"><span class="comment">// OUTPUT:Visit W3School!</span></span><br></pre></td></tr></table></figure>
<h3 id="split-把字符串分割为字符串数组。"><a href="#split-把字符串分割为字符串数组。" class="headerlink" title="split 把字符串分割为字符串数组。"></a>split 把字符串分割为字符串数组。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"How are you doing today?"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.split(<span class="regexp">/\s+/</span>));</span><br><span class="line"><span class="comment">// OUTPUT:How,are,you,doing,today?</span></span><br></pre></td></tr></table></figure>
<h2 id="常见的正则验证"><a href="#常见的正则验证" class="headerlink" title="常见的正则验证"></a>常见的正则验证</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见的 正则表达式 校验</span></span><br><span class="line"><span class="comment">// QQ号、手机号、Email、是否是数字、去掉前后空格、是否存在中文、邮编、身份证、URL、日期格式、IP</span></span><br><span class="line"><span class="keyword">var</span> myRegExp = &#123;</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法QQ号码</span></span><br><span class="line">    isQQ: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1 首位不能是0  ^[1-9]</span></span><br><span class="line">        <span class="comment">// 2 必须是 [5, 11] 位的数字  \d&#123;4, 9&#125;</span></span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^[1-9][0-9]&#123;4,9&#125;$/gim</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'QQ号码格式输入正确'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'请输入正确格式的QQ号码'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法手机号码</span></span><br><span class="line">    isPhone: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^(0|86|17951)?(13[0-9]|15[012356789]|18[0-9]|14[57]|17[678])[0-9]&#123;8&#125;$/</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'手机号码格式输入正确'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'请输入正确格式的手机号码'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法Email地址</span></span><br><span class="line">    isEmail: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/</span>;</span><br><span class="line">        <span class="comment">// var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;</span></span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Email格式输入正确'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'请输入正确格式的Email'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否是数字</span></span><br><span class="line">    isNumber: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^\d+$/</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">'是数字'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">'不是数字'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 去掉前后空格</span></span><br><span class="line">    trim: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^\s+|\s+$/g</span>;</span><br><span class="line">        <span class="keyword">return</span> str.replace(reg, <span class="string">''</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否存在中文</span></span><br><span class="line">    isChinese: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/[\u4e00-\u9fa5]/gm</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 中存在中文'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 中不存在中文'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法邮政编码</span></span><br><span class="line">    isPostcode: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 起始数字不能为0，然后是5个数字  [1-9]\d&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^[1-9]\d&#123;5&#125;$/g</span>;</span><br><span class="line">        <span class="comment">// var reg = /^[1-9]\d&#123;5&#125;(?!\d)$/;</span></span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是合法的邮编格式'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是不合法的邮编格式'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法身份证号码</span></span><br><span class="line">    isIDcard: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^(^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$)|(^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[Xx])$)$/</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是合法的身份证号码'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是不合法的身份证号码'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法URL</span></span><br><span class="line">    isURL: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&amp;?[a-zA-Z0-9_-](\?)?)*)*$/i</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是合法的URL'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是不合法的URL'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法日期格式 yyyy-mm-dd</span></span><br><span class="line">    isDate: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^[1-2][0-9][0-9][0-9]-[0-1]&#123;0,1&#125;[0-9]-[0-3]&#123;0,1&#125;[0-9]$/</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是合法的日期格式'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是不合法的日期格式，yyyy-mm-dd'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 检查字符串是否为合法IP地址</span></span><br><span class="line">    isIP: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1.1.1.1  四段  [0 , 255]</span></span><br><span class="line">        <span class="comment">// 第一段不能为0</span></span><br><span class="line">        <span class="comment">// 每个段不能以0开头</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 本机IP: 58.50.120.18 湖北省荆州市 电信</span></span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))&#123;3&#125;$/gi</span>;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是合法的IP地址'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">' 是不合法的IP地址'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isQQ('80583600'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isPhone('17607160722'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isEmail('80583600@qq.com'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isNumber('100a'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.trim('  100  '));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isChinese('baixiaoming'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isChinese('小明'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isPostcode('412345'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isIDcard('42091119940927001X'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isURL('https://www.baidu.com/'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isDate('2017-4-4'));</span></span><br><span class="line"><span class="comment">// console.log(myRegExp.isIP('1.0.0.0'));</span></span><br></pre></td></tr></table></figure>
<h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数字：^[0-9]*$</span><br><span class="line">n位的数字：^\d&#123;n&#125;$</span><br><span class="line">至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line">m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line">零和非零开头的数字：^(0|[1-9][0-9]*)$</span><br><span class="line">非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$</span><br><span class="line">正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line">有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line">有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$</span><br><span class="line">非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</span><br><span class="line">非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$</span><br><span class="line">非负整数：^\d+$ 或 ^[1-9]\d*|0$</span><br><span class="line">非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span><br><span class="line">非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br><span class="line">非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br><span class="line">正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br><span class="line">负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br><span class="line">浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure>
<h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br><span class="line">英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span><br><span class="line">长度为3-20的所有字符：^.&#123;3,20&#125;$</span><br><span class="line">由26个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line">由26个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line">由26个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line">由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span><br><span class="line">由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span><br><span class="line">中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br><span class="line">可以输入含有^%&amp;&apos;,;=?$\&quot;等字符：[^%&amp;&apos;,;=?$\x22]+</span><br><span class="line">禁止输入含有~的字符：[^~\x22]+</span><br></pre></td></tr></table></figure>
<h2 id="特殊需求的表达式"><a href="#特殊需求的表达式" class="headerlink" title="特殊需求的表达式"></a>特殊需求的表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="line">InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="line">手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="line">电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span><br><span class="line">国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line">身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span><br><span class="line">短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span><br><span class="line">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</span><br><span class="line">日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br><span class="line">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span><br><span class="line">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br><span class="line">xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span><br><span class="line">中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line">双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br><span class="line">空白行的正则表达式：\n\s*\r    (可以用来删除空白行)</span><br><span class="line">HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line">首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line">腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)</span><br><span class="line">中国邮政编码：[1-9]\d&#123;5&#125;(?!\d)    (中国邮政编码为6位数字)</span><br><span class="line">IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)</span><br><span class="line">IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br></pre></td></tr></table></figure>
<h2 id="钱的输入格式"><a href="#钱的输入格式" class="headerlink" title="钱的输入格式"></a>钱的输入格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$</span><br><span class="line">2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</span><br><span class="line">3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</span><br><span class="line">4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</span><br><span class="line">5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line">6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/17/2017-07-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/17/2017-07-17/" itemprop="url">+a、NaN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-17T00:00:00+08:00">
                2017-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于-a"><a href="#关于-a" class="headerlink" title="关于+a"></a>关于+a</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+a是转为number类型，同parseInt(a)</span><br><span class="line">    var a = 1;</span><br><span class="line">    console.log(+a);    //parseInt(a)=1</span><br><span class="line">    console.log(a); //1</span><br></pre></td></tr></table></figure>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>   <span class="comment">//false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/2017-06-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/2017-06-28/" itemprop="url">Mac环境变量配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T00:00:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mac环境变量配置"><a href="#Mac环境变量配置" class="headerlink" title="Mac环境变量配置"></a>Mac环境变量配置</h1><p>mac一般使用<code>bash</code>作为默认shell，如果安装了oh my sh，则默认使用<code>zsh</code>shell。</p>
<h2 id="Mac系统环境变量的加载顺序："><a href="#Mac系统环境变量的加载顺序：" class="headerlink" title="Mac系统环境变量的加载顺序："></a>Mac系统环境变量的加载顺序：</h2><p><code>/etc/profile</code><br><code>/etc/paths</code><br><code>~/.bash_profile</code><br><code>~/.bash_login</code><br><code>~/.profile</code><br><code>~/.bashrc</code></p>
<ul>
<li><code>/etc/profile</code>和<code>/etc/paths</code>是系统级别的，系统启动后就会加载。后面几个是当前用户级的环境变量。</li>
<li>如果<code>~/.bash_profile</code>存在，后面几个文件就会忽略不读，不存在时，才会以此类推读取后面的文件。</li>
<li><code>~/.bashrc</code>没有上述规则，他始终加载，他是在<code>bash shell</code>打开的时候载入的。</li>
</ul>
<h2 id="设置Path的语法"><a href="#设置Path的语法" class="headerlink" title="设置Path的语法"></a>设置Path的语法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中间使用冒号分隔</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure>
<h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>下面的几个文件设置是全局的，修改时需要root权限</p>
<ul>
<li><code>/etc/paths</code> （全局建议修改这个文件 ）<br>编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径.</li>
</ul>
<p>/etc/paths 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin</span><br><span class="line">/usr/bin</span><br><span class="line">/bin</span><br><span class="line">/usr/sbin</span><br><span class="line">/sbin</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>/etc/profile</code> （建议不修改这个文件 ）<br>全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</p>
</li>
<li><p><code>/etc/bashrc</code> （一般在这个文件中添加系统级环境变量）<br>全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</p>
</li>
</ul>
<h2 id="单个用户设置"><a href="#单个用户设置" class="headerlink" title="单个用户设置"></a>单个用户设置</h2><ul>
<li><code>~/.bash_profile</code> （添加用户级环境变量）<br><strong>（注：Linux 里面是 .bashrc 而 Mac 是 .bash_profile）</strong><br>若<code>bash shell</code>是以login方式执行时，才会读取此文件，该文件仅仅执行一次，默认情况下，他设置一些环境变量。<br>设置命令别名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=’ls -la’</span><br></pre></td></tr></table></figure>
<p>设置环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/opt/<span class="built_in">local</span>/bin:/opt/<span class="built_in">local</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>比如设置<code>ANDROID_HOME</code>到PATH：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/shaoc/Library/Android/sdk</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$ANDROID_HOME</span>/platform-tools:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>~/.bashrc</code> 同上</li>
</ul>
<p>一般重启shell设置就会生效，如果想立刻生效，则可执行下面的语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> 相应的文件</span><br></pre></td></tr></table></figure>
<h2 id="zsh中配置环境变量"><a href="#zsh中配置环境变量" class="headerlink" title="zsh中配置环境变量"></a>zsh中配置环境变量</h2><p>在安装了<code>oh my zsh</code>后， <code>.bash_profile</code> 文件中的环境变量就无法起到作用，因为终端默认启动的是<code>zsh</code>，而不是<code>bash shell</code>，所以无法加载。</p>
<p>解决方法1：</p>
<p>在<code>~/.zshrc</code>配置文件中，增加对<code>.bash_profile</code>的引用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>.bash_profile文件示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/pengdan/software/sdk</span><br><span class="line"><span class="built_in">export</span> NDK=/Users/pengdan/software/android-ndk-r10d</span><br><span class="line"><span class="built_in">export</span> GRADLE_HOME=/Users/pengdan/software/gradle-2.4</span><br><span class="line"><span class="built_in">export</span> SUBLIME=/Users/pengdan/home/subin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$ANDROID_HOME</span>/platform-tools:<span class="variable">$GRADLE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SUBLIME</span>:/usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/Users/pengdan/software/apache-tomcat-7.0.70/bin</span><br></pre></td></tr></table></figure>
<p>解决方法2:<br>可以使用zsh的方法进行配置：<br>（1）可以直接在<code>~/.zshrc</code>中添加path或者环境变量<br>（2）在目录<code>~/oh-my-zsh/custom</code>文件夹下的任何<code>.zsh</code>文件中的环境变量都将会加载。</p>
<p>.zshrc:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Path to your oh-my-zsh installation.</span></span><br><span class="line"><span class="built_in">export</span> ZSH=/Users/shaoc/.oh-my-zsh</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> zshconfig=<span class="string">"vim ~/.zshrc"</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>~/oh-my-zsh/custom/my.zsh:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">alias</span> subl=\<span class="string">''</span>/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl<span class="string">'\'</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/2017-05-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/24/2017-05-24/" itemprop="url">关于Homebrew</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T00:00:00+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Homebrew介绍"><a href="#Homebrew介绍" class="headerlink" title="Homebrew介绍"></a>Homebrew介绍</h1><p>官网<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">https://brew.sh/index_zh-cn.html</a></p>
<h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><p><code>Homebrew</code>是macOs下的一个软件包管理器,它是为macOs安装一些Unix上的工具最简单好用灵活的一种方式。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>粘贴下面命令到终端并执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>使用 <code>--verbose</code> 或 <code>-v</code>，很多命令会打印出额外的调试和安装信息</p>
<ul>
<li><code>$ brew --version</code>   查看版本</li>
<li><code>$ brew install formula</code> 安装软件包</li>
<li><code>$ brew uninstall formula</code> 卸载某个软件包</li>
<li><code>$ brew update</code>  更新homebrew到最新版</li>
<li><code>$ brew list</code>  列出所有安装的软件包</li>
<li><code>$ brew search formula</code>  搜索某个软件包</li>
</ul>
<p>更多命令<a href="http://docs.brew.sh/Manpage.html" target="_blank" rel="noopener">http://docs.brew.sh/Manpage.html</a></p>
<h2 id="他能做什么"><a href="#他能做什么" class="headerlink" title="他能做什么"></a>他能做什么</h2><ul>
<li><p>可以使用 <code>Homebrew</code> 安装 Apple 没有预装但你需要的东西，比如</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install wget</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Homebrew</code>会将软件包安装到独立目录，并将其文件软链接至 <code>/usr/local</code> 。</p>
</li>
<li><p><code>Homebrew</code> 不会将文件安装到它本身目录之外，所以您可将 <code>Homebrew</code> 安装到任意位置。</p>
</li>
<li><p>轻松创建你自己的 <code>Homebrew</code> 包。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew create https://foo.com/bar-1.0.tgz</span><br><span class="line">Created /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/bar.rb</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全基于 <code>git</code> 和 <code>ruby</code>，所以自由修改的同时你仍可以轻松撤销你的变更或与上游更新合并。</p>
</li>
<li><p><code>Homebrew</code> 的配方都是简单的 <code>Ruby</code> 脚本：</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wget</span> &lt; Formula</span></span><br><span class="line">  homepage <span class="string">"https://www.gnu.org/software/wget/"</span></span><br><span class="line">  url <span class="string">"https://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz"</span></span><br><span class="line">  sha256 <span class="string">"52126be8cf1bddd7536886e74c053ad7d0ed2aa89b4b630f76785bac21695fcd"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">install</span></span></span><br><span class="line">    system <span class="string">"./configure"</span>, <span class="string">"--prefix=<span class="subst">#&#123;prefix&#125;</span>"</span></span><br><span class="line">    system <span class="string">"make"</span>, <span class="string">"install"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Homebrew</code> 使 macOS 更完整。使用 <code>gem</code> 来安装 <code>gems</code>、用 <code>brew</code> 来安装那些依赖包。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/26/Cordova中的Config.xml配置文件详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/26/Cordova中的Config.xml配置文件详解/" itemprop="url">Cordova、Config.xml中几个重要配置解释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T10:43:15+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Config.xml</code>存储着cordova应用的全局配置信息。</p>
<p>本文重点解释了config.xml中的几个常用配置，比如：<code>access</code> <code>allow-navigation</code> <code>allow-intent</code> 等。</p>
<p>更多信息请查看<a href="https://cordova.apache.org/docs/en/6.x/config_ref/index.html" target="_blank" rel="noopener">官方参考文档</a>。</p>
<h3 id="widget、name、description、author"><a href="#widget、name、description、author" class="headerlink" title="widget、name、description、author"></a>widget、name、description、author</h3><ul>
<li>widget：<code>config.xml</code>中的根元素</li>
<li>name：指定app名，它会显示在设备的主屏幕上</li>
<li>description：app描述</li>
<li>author：作者信息</li>
</ul>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>指定app的根页面，默认是<code>index.html</code><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;widget ...&gt;</span><br><span class="line">   &lt;content src=&quot;startPage.html&quot;&gt;&lt;/content&gt;</span><br><span class="line">&lt;/widget&gt;</span><br></pre></td></tr></table></figure>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><p>配置允许app发起的网络请求（images, XHRs, etc）地址</p>
<p>注意：没有配置<code>access</code>标签时，，只有<code>file://</code>urls被允许访问。但一般情况，app包含一个默认的<code>&lt;access origin=&quot;*&quot;&gt;</code>标签。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--允许访问 google.com:--&gt;</span><br><span class="line">&lt;access origin=&quot;http://google.com&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--允许访问安全地址 google.com (https://):--&gt;</span><br><span class="line">&lt;access origin=&quot;https://google.com&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--允许访问 google.com 的所有子域名, 比如 mail.google.com and docs.google.com:--&gt;</span><br><span class="line">&lt;access origin=&quot;http://*.google.com&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--不阻止任何网络请求，比如 google.com and developer.mozilla.org:--&gt;</span><br><span class="line">&lt;access origin=&quot;*&quot; /&gt;</span><br><span class="line">&lt;!--This is the default value for newly created CLI projects.--&gt;</span><br></pre></td></tr></table></figure>
<p>更多请查看<a href="https://cordova.apache.org/docs/en/6.x/reference/cordova-plugin-whitelist/index.html#network-request-whitelist" target="_blank" rel="noopener">network-request-whitelist</a></p>
<h3 id="allow-navigation"><a href="#allow-navigation" class="headerlink" title="allow-navigation"></a>allow-navigation</h3><p>控制内部的<code>WebView</code>可以加载的<code>URL</code>，只适用于顶级导航。</p>
<p>默认情况下，只允许<code>file://</code>类型的URLS访问。如果要加载其他的urls，需要配置<code>&lt;allow-navigation&gt;</code>标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 允许访问 example.com --&gt;</span><br><span class="line">&lt;allow-navigation href=&quot;http://example.com/*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许使用通配符，协议，主机，地址都可以使用 --&gt;</span><br><span class="line">&lt;allow-navigation href=&quot;*://*.example.com/*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用通配符，允许所有网址访问，包括HTTP and HTTPS and file</span><br><span class="line">     *不推荐使用* --&gt;</span><br><span class="line">&lt;allow-navigation href=&quot;*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 上面的和下面这三条等价 --&gt;</span><br><span class="line">&lt;allow-navigation href=&quot;http://*/*&quot; /&gt;</span><br><span class="line">&lt;allow-navigation href=&quot;https://*/*&quot; /&gt;</span><br><span class="line">&lt;allow-navigation href=&quot;data:*&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>更多请查看<a href="https://cordova.apache.org/docs/en/6.x/reference/cordova-plugin-whitelist/index.html#navigation-whitelist" target="_blank" rel="noopener">cordova-plugin-whitelist</a></p>
<h3 id="allow-intent"><a href="#allow-intent" class="headerlink" title="allow-intent"></a>allow-intent</h3><p>定义app可以要求操作系统打开的链接地址，默认，任何外部请求链接都被禁止。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 允许在浏览器中打开网址 --&gt;</span><br><span class="line">&lt;allow-intent href=&quot;http://*/*&quot; /&gt;</span><br><span class="line">&lt;allow-intent href=&quot;https://*/*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许在浏览器中打开 example.com --&gt;</span><br><span class="line">&lt;allow-intent href=&quot;http://example.com/*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许通配符的使用，在协议、主机、地址 --&gt;</span><br><span class="line">&lt;allow-intent href=&quot;*://*.example.com/*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许在短信应用中打开sms:链接 --&gt;</span><br><span class="line">&lt;allow-intent href=&quot;sms:*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许在电话应用中打开tel:链接 --&gt;</span><br><span class="line">&lt;allow-intent href=&quot;tel:*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许在地图应用中打开geo:链接 --&gt;</span><br><span class="line">&lt;allow-intent href=&quot;geo:*&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 允许在已安装的app中打开未被识别的url地址</span><br><span class="line">     *NOT RECOMMENDED* --&gt;</span><br><span class="line">&lt;allow-intent href=&quot;*&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>查看更多<a href="https://cordova.apache.org/docs/en/6.x/reference/cordova-plugin-whitelist/index.html#intent-whitelist" target="_blank" rel="noopener">cordova-plugin-whitelist</a></p>
<h3 id="engine"><a href="#engine" class="headerlink" title="engine"></a>engine</h3><p>Specifies details about what platform to restore during a prepare.</p>
<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>Specifies details about what plugin to restore during a prepare. This element is automatically added to a project’s config.xml when a plugin is added using the –save flag.</p>
<h3 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h3><p>Persists the value of a CLI variable to be used when restoring a plugin during a prepare. This element is added to config.xml when a plugin that uses CLI variables is added using the –save flag.</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin name=&quot;cordova-plugin-device&quot; spec=&quot;^1.1.0&quot;&gt;</span><br><span class="line">    &lt;variable name=&quot;MY_VARIABLE&quot; value=&quot;my_variable_value&quot; /&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<h3 id="preference"><a href="#preference" class="headerlink" title="preference"></a>preference</h3><p>Sets various options as pairs of name/value attributes. Each preference’s name is case-insensitive. Many preferences are unique to specific platforms, and will be indicated as such.</p>
<p>配置详情：<a href="https://cordova.apache.org/docs/en/6.x/config_ref/index.html#preference" target="_blank" rel="noopener">https://cordova.apache.org/docs/en/6.x/config_ref/index.html#preference</a></p>
<h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><p>If you use the CLI to build applications, you use the plugin command to enable device APIs. This does not modify the top-level config.xml file, so the element does not apply to your workflow. If you work directly in an SDK and using the platform-specific config.xml file as source, you use the tag to enable device-level APIs and external plugins. They often appear with custom values in platform-specific config.xml files. See the API Reference for details on how to specify each feature</p>
<p>更多请参考：<a href="https://cordova.apache.org/docs/en/6.x/config_ref/index.html#feature" target="_blank" rel="noopener">feature</a></p>
<h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><p>When using the CLI to build applications, it is sometimes necessary to specify preferences or other elements specific to a particular platform.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;platform name=&quot;android&quot;&gt;</span><br><span class="line">   &lt;preference name=&quot;Fullscreen&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/platform&gt;</span><br></pre></td></tr></table></figure>
<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><p>Represents your custom script which will be called by Cordova when certain action occurs (for example, after plugin is added or platform prepare logic is invoked). This is useful when you need to extend default Cordova functionality. </p>
<p>更多请参考：<a href="https://cordova.apache.org/docs/en/6.x/config_ref/index.html#hook" target="_blank" rel="noopener">https://cordova.apache.org/docs/en/6.x/config_ref/index.html#hook</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hook type=&quot;after_plugin_install&quot; src=&quot;scripts/afterPluginInstall.js&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>date：2017-04-26 10:37:40<br>版本有变化时，配置可能发生变化，详细信息请参考<a href="https://cordova.apache.org/docs/en/6.x/config_ref/index.html" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/20/Angular-iframe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/20/Angular-iframe/" itemprop="url">Angular - iframe、DomSanitizer模块、单例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T14:45:55+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Angular开发中的几个小知识点"><a href="#Angular开发中的几个小知识点" class="headerlink" title="Angular开发中的几个小知识点"></a>Angular开发中的几个小知识点</h1><h2 id="Angular使用iframe加载外部网站"><a href="#Angular使用iframe加载外部网站" class="headerlink" title="Angular使用iframe加载外部网站"></a>Angular使用iframe加载外部网站</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>项目中，需要使用iframe来加载一个外部网页，但src被Angular的默认安全策略所禁止，无法加载网页。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在Angular中，可以使用iframe用来加载一个外部链接地址，但是src需要使用<code>@angular/platform-browser</code>中的<code>DomSanitizer模块</code>中的<code>sanitizer.bypassSecurityTrustResourceUrl(url)</code>方法来特殊处理，因为Angular中有默认的安全规则会阻止链接的加载。</p>
<p>一个例子：</p>
<p>html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这样无法正常加载网页，被安全策略禁止--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> [<span class="attr">src</span>]=<span class="string">"link"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--需要这样使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">'MainIframe'</span> [<span class="attr">src</span>]=<span class="string">"trust(link)"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或直接处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">'MainIframe'</span> [<span class="attr">src</span>]=<span class="string">"sanitizer.bypassSecurityTrustResourceUrl(link)"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ts:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//引入DomSanitizer模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; DomSanitizer &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">link:<span class="built_in">string</span> = <span class="string">'http://www.baidu.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> sanitizer: DomSanitizer</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello IframeFull Component'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">trust(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sanitizer.bypassSecurityTrustResourceUrl(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试时间：2017-04-26<br>使用Angular版本： 2.2.1</p>
</blockquote>
<h2 id="Angular单例"><a href="#Angular单例" class="headerlink" title="Angular单例"></a>Angular单例</h2><p>angular2一个单例的写法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Injectable&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;UserInterface&#125; <span class="keyword">from</span> <span class="string">"../interface/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个单例模式的config，用于共享全局变量</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Config &#123;</span><br><span class="line">    <span class="keyword">public</span> mode = <span class="string">'dev'</span>;                         <span class="comment">//运行模式 dev or release</span></span><br><span class="line">    <span class="comment">//   public hostURL = 'https://cnodejs.org/api/v1';     //http请求前缀</span></span><br><span class="line">    <span class="keyword">public</span> hostURL = <span class="string">'http://ionichina.com/api/v1'</span>;         <span class="comment">//http请求前缀</span></span><br><span class="line">    <span class="comment">// public hostURL = 'http://localhost:8100/api';         //http请求前缀</span></span><br><span class="line">    <span class="keyword">public</span> isIonic = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> pageLimit = <span class="number">15</span>;                       <span class="comment">//每页多少</span></span><br><span class="line">    <span class="keyword">public</span> DRAFTS_URL = <span class="string">'/data/drafts.json'</span>;     <span class="comment">//草稿本地地址</span></span><br><span class="line">    <span class="keyword">public</span> token: <span class="built_in">string</span> = <span class="string">''</span>;                   <span class="comment">//如果已经登录，存放token，请和localstorage.get('token')同步</span></span><br><span class="line">    <span class="keyword">public</span> loginUser: UserInterface;             <span class="comment">//如果已经登录，存放登录用户信息，请和本地存储保持同步</span></span><br><span class="line">    <span class="keyword">static</span> instance: Config;</span><br><span class="line">    <span class="keyword">static</span> isCreating: <span class="built_in">Boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Config.isCreating) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You can't call new in Config Singleton instance!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">        <span class="keyword">if</span> (Config.instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            Config.isCreating = <span class="literal">true</span>;</span><br><span class="line">            Config.instance = <span class="keyword">new</span> Config();</span><br><span class="line">            Config.isCreating = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Config.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ionic2在scss中访问主题颜色"><a href="#ionic2在scss中访问主题颜色" class="headerlink" title="ionic2在scss中访问主题颜色"></a>ionic2在scss中访问主题颜色</h2><p>通过在<code>scss</code>中引用主题颜色，可以增加程序的可维护性，当程序的主题颜色更改时，引用的地方随之自动更改。</p>
<p>使用<code>background-color: map-get($colors, primary)</code>来引用在主题中定义的颜色。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.progress-inner</span> &#123;</span><br><span class="line">        <span class="attribute">min-width</span>: <span class="number">15%</span>;</span><br><span class="line">        <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">4px</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">map-get</span>($colors, primary);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/Cordova应用中集成Crosswalk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Hunt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易天行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/Cordova应用中集成Crosswalk/" itemprop="url">Cordova应用中集成Crosswalk</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T15:06:20+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在cordova应用中集成crosswalk"><a href="#在cordova应用中集成crosswalk" class="headerlink" title="在cordova应用中集成crosswalk"></a>在cordova应用中集成crosswalk</h1><p><code>Crosswalk</code>是一款开源的Web引擎，其基于 Chromium/Blink 的应用运行环境，对于混合开发的轻量级应用尤为受欢迎。</p>
<p><code>crosswalk</code>是hybrid应用的运行时环境，它用来代替系统自带的<code>webview</code>，以保证应用行为的一致性（css一致，es6支持等），兼容性（完美支持WebRTC，WebAudio，Flexbox布局等）和提高流畅性（相比老旧安卓设备，因为它们自身的webview比较老旧）。</p>
<p>参考链接：<br><a href="https://crosswalk-project.org/" target="_blank" rel="noopener">crosswalk官网</a><br><a href="https://www.npmjs.com/package/cordova-plugin-crosswalk-webview/" target="_blank" rel="noopener">官方npm插件</a><br><a href="https://crosswalk-project.org/documentation/cordova.html" target="_blank" rel="noopener">crosswalk官网 - cordova应用步骤</a></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><code>webview</code>不再依赖于安卓版本，因为每个Android版本WebView的表现都有差别，可以最大限度降低Android碎片化的影响，得到一致的，可预测的行为。</li>
<li>兼容性更好，使用最新的Web技术及API，保证WebRTC, WebAudio, Web Components等</li>
<li>性能更好，与旧版本系统的老webview相比</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增大内存占用率，增加大约30MB</li>
<li>增大APK包的大小，大约17MB</li>
<li>增加安装后的磁盘占用空间，大约50MB</li>
<li><code>Crosswalk WebView</code>的本地存储(IndexedDB, LocalStorage, etc)和系统webview的相互独立</li>
</ul>
<h3 id="安装crosswalk插件"><a href="#安装crosswalk插件" class="headerlink" title="安装crosswalk插件"></a>安装crosswalk插件</h3><p>ionic2或者cordova应用中安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cordova plugin add cordova-plugin-crosswalk-webview --save</span><br></pre></td></tr></table></figure>
<p>构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cordova build android</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpeg"
                alt="Ethan Hunt" />
            
              <p class="site-author-name" itemprop="name">Ethan Hunt</p>
              <p class="site-description motion-element" itemprop="description">Make more time</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ethan Hunt</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
